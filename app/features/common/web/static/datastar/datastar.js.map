{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/utils/dom.ts", "../library/src/utils/paths.ts", "../library/src/utils/text.ts", "../library/src/engine/errors.ts", "../library/src/engine/types.ts", "../library/src/engine/engine.ts", "../library/src/plugins/actions/peek.ts", "../library/src/plugins/actions/setAll.ts", "../library/src/plugins/actions/toggleAll.ts", "../library/src/plugins/attributes/attr.ts", "../library/src/plugins/attributes/bind.ts", "../library/src/plugins/attributes/class.ts", "../library/src/plugins/attributes/computed.ts", "../library/src/plugins/attributes/effect.ts", "../library/src/plugins/backend/shared.ts", "../library/src/plugins/attributes/indicator.ts", "../library/src/plugins/attributes/jsonSignals.ts", "../library/src/utils/tags.ts", "../library/src/utils/timing.ts", "../library/src/utils/view-transitions.ts", "../library/src/plugins/attributes/on.ts", "../library/src/plugins/attributes/onIntersect.ts", "../library/src/plugins/attributes/onInterval.ts", "../library/src/plugins/attributes/onLoad.ts", "../library/src/plugins/attributes/onSignalPatch.ts", "../library/src/plugins/attributes/ref.ts", "../library/src/plugins/attributes/show.ts", "../library/src/plugins/attributes/signals.ts", "../library/src/plugins/attributes/style.ts", "../library/src/plugins/attributes/text.ts", "../library/src/plugins/backend/actions/fetch.ts", "../library/src/plugins/backend/actions/delete.ts", "../library/src/plugins/backend/actions/get.ts", "../library/src/plugins/backend/actions/patch.ts", "../library/src/plugins/backend/actions/post.ts", "../library/src/plugins/backend/actions/put.ts", "../library/src/plugins/backend/watchers/patchElements.ts", "../library/src/plugins/backend/watchers/patchSignals.ts", "../library/src/bundles/datastar.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should elements be patched using the ViewTransition API?\nexport const DefaultElementsUseViewTransitions = false;\n\n// Should a given set of signals patch if they are missing?\nexport const DefaultPatchSignalsOnlyIfMissing = false;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a element is patched into the DOM.\n// Morphs the element into the existing element.\nexport const ElementPatchModeOuter = \"outer\"\n// Replaces the inner HTML of the existing element.\nexport const ElementPatchModeInner = \"inner\"\n// Removes the existing element.\nexport const ElementPatchModeRemove = \"remove\"\n// Replaces the existing element with the new element.\nexport const ElementPatchModeReplace = \"replace\"\n// Prepends the element inside to the existing element.\nexport const ElementPatchModePrepend = \"prepend\"\n// Appends the element inside the existing element.\nexport const ElementPatchModeAppend = \"append\"\n// Inserts the element before the existing element.\nexport const ElementPatchModeBefore = \"before\"\n// Inserts the element after the existing element.\nexport const ElementPatchModeAfter = \"after\"\n\n// Default value for ElementPatchMode\nexport const DefaultElementPatchMode = ElementPatchModeOuter;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\n// An event for patching HTML elements into the DOM.\nexport const EventTypePatchElements = \"datastar-patch-elements\"\n// An event for patching signals.\nexport const EventTypePatchSignals = \"datastar-patch-signals\"\n// #endregion\n\n// #endregion", "import type { HTMLOrSVG } from '../engine/types'\n\nexport function isHTMLOrSVG(el: Node): el is HTMLOrSVG {\n  return el instanceof HTMLElement || el instanceof SVGElement\n}\n", "import type { Paths } from '../engine/types'\n\nexport const isPojo = (obj: any): obj is Record<string, any> =>\n  obj !== null &&\n  typeof obj === 'object' &&\n  (Object.getPrototypeOf(obj) === Object.prototype ||\n    Object.getPrototypeOf(obj) === null)\n\nexport function isEmpty(obj: Record<string, any>): boolean {\n  for (const prop in obj) {\n    if (Object.hasOwn(obj, prop)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function updateLeaves(\n  obj: Record<string, any>,\n  fn: (oldValue: any) => any,\n) {\n  for (const key in obj) {\n    const val = obj[key]\n    if (isPojo(val) || Array.isArray(val)) {\n      updateLeaves(val, fn)\n    } else {\n      obj[key] = fn(val)\n    }\n  }\n}\n\nexport const pathToObj = (paths: Paths): Record<string, any> => {\n  const result: Record<string, any> = {}\n  for (const [path, value] of paths) {\n    const keys = path.split('.')\n    const lastKey = keys.pop()!\n    const obj = keys.reduce((acc, key) => (acc[key] ??= {}), result)\n    obj[lastKey] = value\n  }\n  return result\n}\n", "import type { Modifiers } from '../engine/types'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .toLowerCase()\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) => {\n  try {\n    return JSON.parse(raw)\n  } catch {\n    // If JSON parsing fails, try to evaluate as a JavaScript object\n    // This is less safe and should be used with caution\n    return Function(`return (${raw})`)()\n  }\n}\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n", "import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport type { InitContext, RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(ctx: InitContext, reason: string, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(ctx: RuntimeContext, reason: string, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      // validSignals:\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n", "import { DATASTAR } from './consts'\nexport type PluginType = 'attribute' | 'watcher' | 'action'\nexport type Requirement = 'allowed' | 'must' | 'denied' | 'exclusive'\n\n// export type ReactiveNode = Signal | Computed | Effect\n// export type Subscriber = Computed | Effect\nexport type OnRemovalFn = () => void\n\nexport type DatastarPlugin = AttributePlugin | WatcherPlugin | ActionPlugin\n\nexport const DATASTAR_SIGNAL_PATCH_EVENT = `${DATASTAR}-signal-patch`\nexport type JSONPatch = Record<string, any> & { length?: never }\nexport type Paths = [string, any][]\n\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_PATCH_EVENT]: CustomEvent<JSONPatch>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accessible via a `data-${name}` attribute on an element\nexport type AttributePlugin = {\n  type: 'attribute'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  returnsValue?: boolean // If the expression returns a value\n  shouldEvaluate?: boolean // If the value should be evaluated\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the Datastar instance\nexport type WatcherPlugin = {\n  type: 'watcher'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport type ActionPlugin = {\n  type: 'action'\n  name: string // The name of the plugin\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n\nexport type MergePatchArgs = {\n  ifMissing?: boolean\n}\n\nexport type InitContext = {\n  plugin: DatastarPlugin // The plugin instance\n  actions: Readonly<ActionPlugins> // All registered actions\n  root: Record<string, any> // global signals and computed signals\n  filtered: (opts?: SignalFilterOptions, obj?: JSONPatch) => Record<string, any>\n  signal<T>(initialValue?: T | undefined): Signal<T> // creates a signal\n  computed<T>(getter: (previousValue?: T) => T): Computed<T> // creates a computed signal\n  effect(fn: (...args: any[]) => void): OnRemovalFn // creates an effect\n  mergePatch: (patch: JSONPatch, args?: MergePatchArgs) => void\n  mergePaths: (paths: Paths, args?: MergePatchArgs) => void\n  peek: <T>(fn: () => T) => T // returns the current state of the signal without subscribing\n  getPath: <T = any>(path: string) => T | undefined // get a value from the root\n  startBatch: () => void // starts a signal batch\n  endBatch: () => void // ends a signal batch\n  initErr: (reason: string, metadata?: object) => Error\n}\n\nexport type HTMLOrSVG = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\nexport type ReactiveExpressionFn = <T>(...argsThenDeps: any[]) => T // a reactive expression\n\nexport type RuntimeContext = InitContext & {\n  el: HTMLOrSVG // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the modifiers and their tags\n  rx: ReactiveExpressionFn // function to generate a reactive expression\n  fnContent?: string // the content of the function\n  evt?: Event // the event that triggered the plugin\n  runtimeErr: (reason: string, metadata?: object) => Error\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n\nexport type EventCallbackHandler = (...args: any[]) => void\n\nexport type SignalFilter = RegExp\nexport type SignalFilterOptions = {\n  include?: RegExp | string\n  exclude?: RegExp | string\n}\n\nexport type Signal<T = any> = {\n  (): T\n  (value: T): boolean\n}\n\nexport type Computed<T = any> = () => T\n\nexport type Effect = () => void\n", "import { isHTMLOrSVG } from '../utils/dom'\nimport { isPojo, pathToObj } from '../utils/paths'\nimport { camel, snake } from '../utils/text'\nimport { DATASTAR, DSP, DSS } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport type {\n  ActionPlugins,\n  AttributePlugin,\n  Computed,\n  DatastarPlugin,\n  Effect,\n  HTMLOrSVG,\n  InitContext,\n  JSONPatch,\n  MergePatchArgs,\n  OnRemovalFn,\n  Paths,\n  RuntimeContext,\n  RuntimeExpressionFunction,\n  Signal,\n  SignalFilterOptions,\n} from './types'\nimport { DATASTAR_SIGNAL_PATCH_EVENT } from './types'\n\n/**\n * Custom signals implementation based on Alien Signals\n */\n\ninterface ReactiveNode {\n  deps_?: Link\n  depsTail_?: Link\n  subs_?: Link\n  subsTail_?: Link\n  flags_: ReactiveFlags\n}\n\ninterface Link {\n  dep_: ReactiveNode\n  sub_: ReactiveNode\n  prevSub_?: Link\n  nextSub_?: Link\n  prevDep_?: Link\n  nextDep_?: Link\n}\n\ninterface Stack<T> {\n  value_: T\n  prev_?: Stack<T>\n}\n\nenum ReactiveFlags {\n  None = 0,\n  Mutable = 1 << 0,\n  Watching = 1 << 1,\n  RecursedCheck = 1 << 2,\n  Recursed = 1 << 3,\n  Dirty = 1 << 4,\n  Pending = 1 << 5,\n}\n\nenum EffectFlags {\n  Queued = 1 << 6,\n}\n\ninterface AlienEffect extends ReactiveNode {\n  fn_(): void\n}\n\ninterface AlienComputed<T = any> extends ReactiveNode {\n  value_?: T\n  getter(previousValue?: T): T\n}\n\ninterface AlienSignal<T = any> extends ReactiveNode {\n  previousValue: T\n  value_: T\n}\n\nconst currentPatch: Paths = []\nconst queuedEffects: (AlienEffect | undefined)[] = []\nlet batchDepth = 0\nlet notifyIndex = 0\nlet queuedEffectsLength = 0\nlet activeSub: ReactiveNode | undefined\n\nconst startBatch = (): void => {\n  batchDepth++\n}\n\nconst endBatch = (): void => {\n  if (!--batchDepth) {\n    flush()\n    dispatch()\n  }\n}\n\nconst signal = <T>(initialValue?: T): Signal<T> => {\n  return signalOper.bind(0, {\n    previousValue: initialValue,\n    value_: initialValue,\n    flags_: 1 satisfies ReactiveFlags.Mutable,\n  }) as Signal<T>\n}\n\nconst computedSymbol = Symbol('computed')\nconst computed = <T>(getter: (previousValue?: T) => T): Computed<T> => {\n  const c = computedOper.bind(0, {\n    flags_: 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty,\n    getter,\n  }) as Computed<T>\n  // @ts-ignore\n  c[computedSymbol] = 1\n  return c\n}\n\nconst effect = (fn: () => void): Effect => {\n  const e: AlienEffect = {\n    fn_: fn,\n    flags_: 2 satisfies ReactiveFlags.Watching,\n  }\n  if (activeSub) {\n    link(e, activeSub)\n  }\n  const prev = setCurrentSub(e)\n  startBatch()\n  try {\n    e.fn_()\n  } finally {\n    endBatch()\n    setCurrentSub(prev)\n  }\n  return effectOper.bind(0, e)\n}\n\nconst peek = <T>(fn: () => T): T => {\n  const prev = setCurrentSub(undefined)\n  try {\n    return fn()\n  } finally {\n    setCurrentSub(prev)\n  }\n}\n\nconst flush = () => {\n  while (notifyIndex < queuedEffectsLength) {\n    const effect = queuedEffects[notifyIndex]!\n    queuedEffects[notifyIndex++] = undefined\n    run(effect, (effect.flags_ &= ~EffectFlags.Queued))\n  }\n  notifyIndex = 0\n  queuedEffectsLength = 0\n}\n\nconst update = (signal: AlienSignal | AlienComputed): boolean => {\n  if ('getter' in signal) {\n    return updateComputed(signal)\n  }\n  return updateSignal(signal, signal.value_)\n}\n\nconst setCurrentSub = (sub?: ReactiveNode): ReactiveNode | undefined => {\n  const prevSub = activeSub\n  activeSub = sub\n  return prevSub\n}\n\nconst updateComputed = (c: AlienComputed): boolean => {\n  const prevSub = setCurrentSub(c)\n  startTracking(c)\n  try {\n    const oldValue = c.value_\n    return oldValue !== (c.value_ = c.getter(oldValue))\n  } finally {\n    setCurrentSub(prevSub)\n    endTracking(c)\n  }\n}\n\nconst updateSignal = (s: AlienSignal, value: any): boolean => {\n  s.flags_ = 1 satisfies ReactiveFlags.Mutable\n  return s.previousValue !== (s.previousValue = value)\n}\n\nconst notify = (e: AlienEffect): void => {\n  const flags = e.flags_\n  if (!(flags & EffectFlags.Queued)) {\n    e.flags_ = flags | EffectFlags.Queued\n    const subs = e.subs_\n    if (subs) {\n      notify(subs.sub_ as AlienEffect)\n    } else {\n      queuedEffects[queuedEffectsLength++] = e\n    }\n  }\n}\n\nconst run = (e: AlienEffect, flags: ReactiveFlags): void => {\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(e.deps_!, e))\n  ) {\n    const prev = setCurrentSub(e)\n    startTracking(e)\n    startBatch()\n    try {\n      e.fn_()\n    } finally {\n      endBatch()\n      setCurrentSub(prev)\n      endTracking(e)\n    }\n    return\n  }\n  if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    e.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  let link = e.deps_\n  while (link) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n    if (depFlags & EffectFlags.Queued) {\n      run(dep as AlienEffect, (dep.flags_ = depFlags & ~EffectFlags.Queued))\n    }\n    link = link.nextDep_\n  }\n}\n\nconst computedOper = <T>(c: AlienComputed<T>): T => {\n  const flags = c.flags_\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(c.deps_!, c))\n  ) {\n    if (updateComputed(c)) {\n      const subs = c.subs_\n      if (subs) {\n        shallowPropagate(subs)\n      }\n    }\n  } else if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    c.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  if (activeSub) {\n    link(c, activeSub)\n  }\n  return c.value_!\n}\n\nconst signalOper = <T>(s: AlienSignal<T>, ...value: [T]): T | boolean => {\n  if (value.length) {\n    const newValue = value[0]\n    if (s.value_ !== (s.value_ = newValue)) {\n      s.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n      const subs = s.subs_\n      if (subs) {\n        propagate(subs)\n        if (!batchDepth) {\n          flush()\n        }\n      }\n      return true\n    }\n    return false\n  }\n  const currentValue = s.value_\n  if (s.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n    if (updateSignal(s, currentValue)) {\n      const subs_ = s.subs_\n      if (subs_) {\n        shallowPropagate(subs_)\n      }\n    }\n  }\n  if (activeSub) {\n    link(s, activeSub)\n  }\n  return currentValue\n}\n\nconst effectOper = (e: AlienEffect): void => {\n  let dep = e.deps_\n  while (dep) {\n    dep = unlink(dep, e)\n  }\n  const sub = e.subs_\n  if (sub) {\n    unlink(sub)\n  }\n  e.flags_ = 0 satisfies ReactiveFlags.None\n}\n\nconst link = (dep: ReactiveNode, sub: ReactiveNode): void => {\n  const prevDep = sub.depsTail_\n  if (prevDep && prevDep.dep_ === dep) {\n    return\n  }\n  let nextDep: Link | undefined\n  const recursedCheck = sub.flags_ & (4 satisfies ReactiveFlags.RecursedCheck)\n  if (recursedCheck) {\n    nextDep = prevDep ? prevDep.nextDep_ : sub.deps_\n    if (nextDep && nextDep.dep_ === dep) {\n      sub.depsTail_ = nextDep\n      return\n    }\n  }\n  const prevSub = dep.subsTail_\n  if (\n    prevSub &&\n    prevSub.sub_ === sub &&\n    (!recursedCheck || isValidLink(prevSub, sub))\n  ) {\n    return\n  }\n  const newLink =\n    (sub.depsTail_ =\n    dep.subsTail_ =\n      {\n        dep_: dep,\n        sub_: sub,\n        prevDep_: prevDep,\n        nextDep_: nextDep,\n        prevSub_: prevSub,\n      })\n  if (nextDep) {\n    nextDep.prevDep_ = newLink\n  }\n  if (prevDep) {\n    prevDep.nextDep_ = newLink\n  } else {\n    sub.deps_ = newLink\n  }\n  if (prevSub) {\n    prevSub.nextSub_ = newLink\n  } else {\n    dep.subs_ = newLink\n  }\n}\n\nconst unlink = (link: Link, sub_ = link.sub_): Link | undefined => {\n  const dep_ = link.dep_\n  const prevDep_ = link.prevDep_\n  const nextDep_ = link.nextDep_\n  const nextSub_ = link.nextSub_\n  const prevSub_ = link.prevSub_\n  if (nextDep_) {\n    nextDep_.prevDep_ = prevDep_\n  } else {\n    sub_.depsTail_ = prevDep_\n  }\n  if (prevDep_) {\n    prevDep_.nextDep_ = nextDep_\n  } else {\n    sub_.deps_ = nextDep_\n  }\n  if (nextSub_) {\n    nextSub_.prevSub_ = prevSub_\n  } else {\n    dep_.subsTail_ = prevSub_\n  }\n  if (prevSub_) {\n    prevSub_.nextSub_ = nextSub_\n  } else if (!(dep_.subs_ = nextSub_)) {\n    if ('getter' in dep_) {\n      let toRemove = dep_.deps_\n      if (toRemove) {\n        dep_.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n        do {\n          toRemove = unlink(toRemove, dep_)\n        } while (toRemove)\n      }\n    } else if (!('previousValue' in dep_)) {\n      effectOper(dep_ as AlienEffect)\n    }\n  }\n  return nextDep_\n}\n\nconst propagate = (link: Link): void => {\n  let next = link.nextSub_\n  let stack: Stack<Link | undefined> | undefined\n\n  top: while (true) {\n    const sub = link.sub_\n\n    let flags = sub.flags_\n\n    if (flags & (3 as ReactiveFlags.Mutable | ReactiveFlags.Watching)) {\n      if (\n        !(\n          flags &\n          (60 as\n            | ReactiveFlags.RecursedCheck\n            | ReactiveFlags.Recursed\n            | ReactiveFlags.Dirty\n            | ReactiveFlags.Pending)\n        )\n      ) {\n        sub.flags_ = flags | (32 satisfies ReactiveFlags.Pending)\n      } else if (\n        !(flags & (12 as ReactiveFlags.RecursedCheck | ReactiveFlags.Recursed))\n      ) {\n        flags = 0 satisfies ReactiveFlags.None\n      } else if (!(flags & (4 satisfies ReactiveFlags.RecursedCheck))) {\n        sub.flags_ =\n          (flags & ~(8 satisfies ReactiveFlags.Recursed)) |\n          (32 satisfies ReactiveFlags.Pending)\n      } else if (\n        !(flags & (48 as ReactiveFlags.Dirty | ReactiveFlags.Pending)) &&\n        isValidLink(link, sub)\n      ) {\n        sub.flags_ =\n          flags | (40 as ReactiveFlags.Recursed | ReactiveFlags.Pending)\n        flags &= 1 satisfies ReactiveFlags.Mutable\n      } else {\n        flags = 0 satisfies ReactiveFlags.None\n      }\n\n      if (flags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n\n      if (flags & (1 satisfies ReactiveFlags.Mutable)) {\n        const subSubs = sub.subs_\n        if (subSubs) {\n          link = subSubs\n          if (subSubs.nextSub_) {\n            stack = { value_: next, prev_: stack }\n            next = link.nextSub_\n          }\n          continue\n        }\n      }\n    }\n\n    if ((link = next!)) {\n      next = link.nextSub_\n      continue\n    }\n\n    while (stack) {\n      link = stack.value_!\n      stack = stack.prev_\n      if (link) {\n        next = link.nextSub_\n        continue top\n      }\n    }\n\n    break\n  }\n}\n\nconst startTracking = (sub: ReactiveNode): void => {\n  sub.depsTail_ = undefined\n  sub.flags_ =\n    (sub.flags_ &\n      ~(56 as\n        | ReactiveFlags.Recursed\n        | ReactiveFlags.Dirty\n        | ReactiveFlags.Pending)) |\n    (4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst endTracking = (sub: ReactiveNode): void => {\n  const depsTail_ = sub.depsTail_\n  let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_\n  while (toRemove) {\n    toRemove = unlink(toRemove, sub)\n  }\n  sub.flags_ &= ~(4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst checkDirty = (link: Link, sub: ReactiveNode): boolean => {\n  let stack: Stack<Link> | undefined\n  let checkDepth = 0\n\n  top: while (true) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n\n    let dirty = false\n\n    if (sub.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n      dirty = true\n    } else if (\n      (depFlags & (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)) ===\n      (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)\n    ) {\n      if (update(dep as AlienSignal | AlienComputed)) {\n        const subs = dep.subs_!\n        if (subs.nextSub_) {\n          shallowPropagate(subs)\n        }\n        dirty = true\n      }\n    } else if (\n      (depFlags & (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)) ===\n      (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)\n    ) {\n      if (link.nextSub_ || link.prevSub_) {\n        stack = { value_: link, prev_: stack }\n      }\n      link = dep.deps_!\n      sub = dep\n      ++checkDepth\n      continue\n    }\n\n    if (!dirty && link.nextDep_) {\n      link = link.nextDep_\n      continue\n    }\n\n    while (checkDepth) {\n      --checkDepth\n      const firstSub = sub.subs_!\n      const hasMultipleSubs = firstSub.nextSub_\n      if (hasMultipleSubs) {\n        link = stack!.value_\n        stack = stack!.prev_\n      } else {\n        link = firstSub\n      }\n      if (dirty) {\n        if (update(sub as AlienSignal | AlienComputed)) {\n          if (hasMultipleSubs) {\n            shallowPropagate(firstSub)\n          }\n          sub = link.sub_\n          continue\n        }\n      } else {\n        sub.flags_ &= ~(32 satisfies ReactiveFlags.Pending)\n      }\n      sub = link.sub_\n      if (link.nextDep_) {\n        link = link.nextDep_\n        continue top\n      }\n      dirty = false\n    }\n\n    return dirty\n  }\n}\n\nconst shallowPropagate = (link: Link): void => {\n  do {\n    const sub = link.sub_\n    const nextSub = link.nextSub_\n    const subFlags = sub.flags_\n    if (\n      (subFlags & (48 as ReactiveFlags.Pending | ReactiveFlags.Dirty)) ===\n      (32 satisfies ReactiveFlags.Pending)\n    ) {\n      sub.flags_ = subFlags | (16 satisfies ReactiveFlags.Dirty)\n      if (subFlags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n    }\n    link = nextSub!\n  } while (link)\n}\n\nconst isValidLink = (checkLink: Link, sub: ReactiveNode): boolean => {\n  const depsTail = sub.depsTail_\n  if (depsTail) {\n    let link = sub.deps_!\n    do {\n      if (link === checkLink) {\n        return true\n      }\n      if (link === depsTail) {\n        break\n      }\n      link = link.nextDep_!\n    } while (link)\n  }\n  return false\n}\n\nconst getPath = <T = any>(path: string): T | undefined => {\n  let result = root\n  const split = path.split('.')\n  for (const path of split) {\n    if (result == null || !Object.hasOwn(result, path)) {\n      return\n    }\n    result = result[path]\n  }\n  return result as T\n}\n\nexport const DELETE = Symbol('delete')\nconst deep = (value: any, prefix = ''): any => {\n  const isArr = Array.isArray(value)\n  if (isArr || isPojo(value)) {\n    const deepObj = (isArr ? [] : {}) as Record<string, Signal>\n    for (const key in value) {\n      deepObj[key] = signal(\n        deep((value as Record<string, Signal>)[key], `${prefix + key}.`),\n      )\n    }\n    const keys = signal(0)\n    return new Proxy(deepObj, {\n      get(_, prop: string) {\n        if (!(prop === 'toJSON' && !Object.hasOwn(deepObj, prop))) {\n          if (isArr && prop in Array.prototype) {\n            keys()\n            return deepObj[prop]\n          } else {\n            if (typeof prop === 'symbol') {\n              return deepObj[prop]\n            }\n            if (!Object.hasOwn(deepObj, prop) || deepObj[prop]() == null) {\n              deepObj[prop] = signal('')\n              dispatch(prefix + prop, '')\n              keys(keys() + 1)\n            }\n            return deepObj[prop]()\n          }\n        }\n      },\n      set(_, prop: string, newValue) {\n        const path = prefix + prop\n        if (newValue === DELETE) {\n          if (Object.hasOwn(deepObj, prop)) {\n            delete deepObj[prop]\n            dispatch(path, DELETE)\n            keys(keys() + 1)\n          }\n        } else {\n          if (isArr && prop === 'length') {\n            const diff = (deepObj[prop] as unknown as number) - newValue\n            deepObj[prop] = newValue\n            if (diff > 0) {\n              const patch: Record<string, any> = {}\n              for (let i = newValue; i < deepObj[prop]; i++) {\n                patch[i] = null\n              }\n              dispatch(prefix.slice(0, -1), patch)\n              keys(keys() + 1)\n            }\n          } else {\n            if (Object.hasOwn(deepObj, prop)) {\n              if (newValue == null) {\n                if (deepObj[prop](null)) {\n                  dispatch(path, null)\n                }\n              } else {\n                if (Object.hasOwn(newValue, computedSymbol)) {\n                  deepObj[prop] = newValue\n                  dispatch(path, '')\n                } else {\n                  if (deepObj[prop](deep(newValue, `${path}.`))) {\n                    dispatch(path, newValue)\n                  }\n                }\n              }\n            } else {\n              if (newValue != null) {\n                if (Object.hasOwn(newValue, computedSymbol)) {\n                  deepObj[prop] = newValue\n                  dispatch(path, '')\n                } else {\n                  deepObj[prop] = signal(deep(newValue, `${path}.`))\n                  dispatch(path, newValue)\n                }\n                keys(keys() + 1)\n              }\n            }\n          }\n        }\n\n        return true\n      },\n      deleteProperty(_, prop: string) {\n        if (Object.hasOwn(deepObj, prop)) {\n          if (deepObj[prop](null)) {\n            dispatch(prefix + prop, null)\n          }\n        }\n\n        return true\n      },\n      ownKeys() {\n        keys()\n        return Reflect.ownKeys(deepObj)\n      },\n      has(_, prop) {\n        keys()\n        return prop in deepObj\n      },\n    })\n  }\n  return value\n}\n\nconst dispatch = (path?: string, value?: any) => {\n  if (path !== undefined && value !== undefined) {\n    currentPatch.push([path, value])\n  }\n  if (!batchDepth && currentPatch.length) {\n    const detail = pathToObj(currentPatch)\n    currentPatch.length = 0\n    document.dispatchEvent(\n      new CustomEvent<JSONPatch>(DATASTAR_SIGNAL_PATCH_EVENT, {\n        detail,\n      }),\n    )\n  }\n}\n\nconst mergePatch = (\n  patch: JSONPatch,\n  { ifMissing }: MergePatchArgs = {},\n): void => {\n  startBatch()\n  for (const key in patch) {\n    if (patch[key] == null) {\n      if (!ifMissing) {\n        delete root[key]\n      }\n    } else {\n      mergeInner(patch[key], key, root, '', ifMissing)\n    }\n  }\n  endBatch()\n}\n\nconst mergePaths = (paths: Paths, options: MergePatchArgs = {}): void =>\n  mergePatch(pathToObj(paths), options)\n\nconst mergeInner = (\n  patch: any,\n  target: string,\n  targetParent: Record<string, any>,\n  prefix: string,\n  ifMissing: boolean | undefined,\n): void => {\n  if (isPojo(patch)) {\n    if (\n      !(\n        Object.hasOwn(targetParent, target) &&\n        (isPojo(targetParent[target]) || Array.isArray(targetParent[target]))\n      )\n    ) {\n      targetParent[target] = {}\n    }\n\n    for (const key in patch) {\n      if (patch[key] == null) {\n        if (!ifMissing) {\n          delete targetParent[target][key]\n        }\n      } else {\n        mergeInner(\n          patch[key],\n          key,\n          targetParent[target],\n          `${prefix + target}.`,\n          ifMissing,\n        )\n      }\n    }\n  } else if (!(ifMissing && Object.hasOwn(targetParent, target))) {\n    targetParent[target] = patch\n  }\n}\n\nfunction filtered(\n  { include = /.*/, exclude = /(?!)/ }: SignalFilterOptions = {},\n  obj: JSONPatch = root,\n): Record<string, any> {\n  // We need to find all valid signal paths in the object\n  const paths: Paths = []\n  const stack: [any, string][] = [[obj, '']]\n\n  while (stack.length) {\n    const [node, prefix] = stack.pop()!\n\n    for (const key in node) {\n      const path = prefix + key\n      if (isPojo(node[key])) {\n        stack.push([node[key], `${path}.`])\n      } else if (\n        toRegExp(include).test(path) &&\n        !toRegExp(exclude).test(path)\n      ) {\n        paths.push([path, getPath(path)])\n      }\n    }\n  }\n\n  return pathToObj(paths)\n}\n\nfunction toRegExp(val: string | RegExp): RegExp {\n  if (typeof val === 'string') {\n    return RegExp(val.replace(/^\\/|\\/$/g, ''))\n  }\n\n  return val\n}\n\nconst root: Record<string, any> = deep({})\n\n/**\n * Turn data-* attributes into reactive expressions\n * This is the core of the Datastar\n */\n\nconst actions: ActionPlugins = {}\nconst plugins: AttributePlugin[] = []\nlet pluginRegexs: RegExp[] = []\n\n// Map of cleanup functions by element, keyed by a dataset key-value hash\nconst removals = new Map<HTMLOrSVG, Map<string, OnRemovalFn>>()\n\nlet mutationObserver: MutationObserver | null = null\n\nlet alias = ''\nexport function setAlias(value: string) {\n  alias = value\n}\nexport function aliasify(name: string) {\n  return alias ? `data-${alias}-${name}` : `data-${name}`\n}\n\nexport function load(...pluginsToLoad: DatastarPlugin[]) {\n  for (const plugin of pluginsToLoad) {\n    const ctx: InitContext = {\n      plugin,\n      actions,\n      root,\n      filtered,\n      signal,\n      computed,\n      effect,\n      mergePatch,\n      mergePaths,\n      peek,\n      getPath,\n      startBatch,\n      endBatch,\n      initErr: 0 as any,\n    }\n    ctx.initErr = initErr.bind(0, ctx)\n\n    if (plugin.type === 'action') {\n      actions[plugin.name] = plugin\n    } else if (plugin.type === 'attribute') {\n      plugins.push(plugin)\n      plugin.onGlobalInit?.(ctx)\n    } else if (plugin.type === 'watcher') {\n      plugin.onGlobalInit?.(ctx)\n    } else {\n      throw ctx.initErr('InvalidPluginType')\n    }\n  }\n\n  // Sort attribute plugins by descending length then alphabetically\n  plugins.sort((a, b) => {\n    const lenDiff = b.name.length - a.name.length\n    if (lenDiff !== 0) return lenDiff\n    return a.name.localeCompare(b.name)\n  })\n\n  pluginRegexs = plugins.map((plugin) => RegExp(`^${plugin.name}([A-Z]|_|$)`))\n}\n\nfunction applyEls(els: Iterable<HTMLOrSVG>): void {\n  const ignore = `[${aliasify('ignore')}]`\n  for (const el of els) {\n    if (!el.closest(ignore)) {\n      for (const key in el.dataset) {\n        applyAttributePlugin(el, key, el.dataset[key]!)\n      }\n    }\n  }\n}\n\nfunction cleanupEls(els: Iterable<HTMLOrSVG>): void {\n  for (const el of els) {\n    const cleanups = removals.get(el)\n    // If removals has el, delete it and run all cleanup functions\n    if (removals.delete(el)) {\n      for (const cleanup of cleanups!.values()) {\n        cleanup()\n      }\n      cleanups!.clear()\n    }\n  }\n}\n\n// Apply all plugins to the entire DOM or a provided element\nexport function apply(root: HTMLOrSVG = document.body) {\n  // Delay applying plugins to give custom plugins a chance to load\n  queueMicrotask(() => {\n    applyEls([root])\n    applyEls(root.querySelectorAll<HTMLOrSVG>('*'))\n\n    // Monitor the entire document body or a provided element for changes\n    // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n    if (!mutationObserver) {\n      mutationObserver = new MutationObserver(observe)\n      mutationObserver.observe(root, {\n        subtree: true,\n        childList: true,\n        attributes: true,\n      })\n    }\n  })\n}\n\nfunction applyAttributePlugin(\n  el: HTMLOrSVG,\n  attrKey: string,\n  value: string,\n): void {\n  if (attrKey.startsWith(alias)) {\n    const rawKey = camel(alias ? attrKey.slice(alias.length) : attrKey)\n    const plugin = plugins.find((_, i) => pluginRegexs[i].test(rawKey))\n    if (plugin) {\n      // Extract the key and modifiers\n      let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/__+/)\n\n      const hasKey = !!key\n      if (hasKey) {\n        key = camel(key)\n      }\n      const hasValue = !!value\n\n      // Create the runtime context\n      const ctx: RuntimeContext = {\n        plugin,\n        actions,\n        root,\n        filtered,\n        signal,\n        computed,\n        effect,\n        mergePatch,\n        mergePaths,\n        peek,\n        getPath,\n        startBatch,\n        endBatch,\n        initErr: 0 as any,\n        el,\n        rawKey,\n        key,\n        value,\n        mods: new Map(),\n        runtimeErr: 0 as any,\n        rx: 0 as any,\n      }\n      ctx.initErr = initErr.bind(0, ctx)\n      ctx.runtimeErr = runtimeErr.bind(0, ctx)\n      if (\n        plugin.shouldEvaluate === undefined ||\n        plugin.shouldEvaluate === true\n      ) {\n        ctx.rx = generateReactiveExpression(ctx)\n      }\n\n      // Check the requirements\n      const keyReq = plugin.keyReq || 'allowed'\n      if (hasKey) {\n        if (keyReq === 'denied') {\n          throw ctx.runtimeErr(`${plugin.name}KeyNotAllowed`)\n        }\n      } else if (keyReq === 'must') {\n        throw ctx.runtimeErr(`${plugin.name}KeyRequired`)\n      }\n\n      const valReq = plugin.valReq || 'allowed'\n      if (hasValue) {\n        if (valReq === 'denied') {\n          throw ctx.runtimeErr(`${plugin.name}ValueNotAllowed`)\n        }\n      } else if (valReq === 'must') {\n        throw ctx.runtimeErr(`${plugin.name}ValueRequired`)\n      }\n\n      // Check for exclusive requirements\n      if (keyReq === 'exclusive' || valReq === 'exclusive') {\n        if (hasKey && hasValue) {\n          throw ctx.runtimeErr(`${plugin.name}KeyAndValueProvided`)\n        }\n        if (!hasKey && !hasValue) {\n          throw ctx.runtimeErr(`${plugin.name}KeyOrValueRequired`)\n        }\n      }\n\n      for (const rawMod of rawModifiers) {\n        const [label, ...mod] = rawMod.split('.')\n        ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())))\n      }\n\n      const cleanup = plugin.onLoad(ctx)\n      if (cleanup) {\n        let cleanups = removals.get(el)\n        if (cleanups) {\n          cleanups.get(rawKey)?.()\n        } else {\n          cleanups = new Map()\n          removals.set(el, cleanups)\n        }\n        cleanups.set(rawKey, cleanup)\n      }\n    }\n  }\n}\n\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe(mutations: MutationRecord[]) {\n  const ignore = `[${aliasify('ignore')}]`\n\n  for (const {\n    target,\n    type,\n    attributeName,\n    addedNodes,\n    removedNodes,\n  } of mutations) {\n    if (type === 'childList') {\n      for (const node of removedNodes) {\n        if (isHTMLOrSVG(node)) {\n          cleanupEls([node])\n          cleanupEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n\n      for (const node of addedNodes) {\n        if (isHTMLOrSVG(node)) {\n          applyEls([node])\n          applyEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n    } else if (type === 'attributes') {\n      // If el has a parent with data-ignore, skip it\n      if (isHTMLOrSVG(target) && !target.closest(ignore)) {\n        const key = camel(attributeName!.slice(5))\n        const value = target.getAttribute(attributeName!)\n        if (value === null) {\n          const cleanups = removals.get(target)\n          if (cleanups) {\n            cleanups.get(key)?.()\n            cleanups.delete(key)\n          }\n        } else {\n          applyAttributePlugin(target, key, value)\n        }\n      }\n    }\n  }\n}\n\nfunction generateReactiveExpression(\n  ctx: RuntimeContext,\n): RuntimeExpressionFunction {\n  let expr = ''\n\n  const attrPlugin = (ctx.plugin as AttributePlugin) || undefined\n\n  // plugin is guaranteed to be an attribute plugin\n  if (attrPlugin?.returnsValue) {\n    // This regex allows Datastar expressions to support nested\n    // regex and strings that contain ; without breaking.\n    //\n    // Each of these regex defines a block type we want to match\n    // (importantly we ignore the content within these blocks):\n    //\n    // regex            \\/(\\\\\\/|[^\\/])*\\/\n    // double quotes      \"(\\\\\"|[^\\\"])*\"\n    // single quotes      '(\\\\'|[^'])*'\n    // ticks              `(\\\\`|[^`])*`\n    // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n    //\n    // The iife support is (intentionally) limited. It only supports\n    // function and arrow syntax with no arguments, and no nested IIFEs.\n    //\n    // We also want to match the non delimiter part of statements\n    // note we only support ; statement delimiters:\n    //\n    // [^;]\n    //\n    const statementRe =\n      /(\\/(\\\\\\/|[^/])*\\/|\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;){]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm\n    const statements = ctx.value.trim().match(statementRe)\n    if (statements) {\n      const lastIdx = statements.length - 1\n      const last = statements[lastIdx].trim()\n      if (!last.startsWith('return')) {\n        statements[lastIdx] = `return (${last});`\n      }\n      expr = statements.join(';\\n')\n    }\n  } else {\n    expr = ctx.value.trim()\n  }\n\n  // Replace signal references with bracket notation\n  // Examples:\n  //   $count          \u2192 $['count']\n  //   $count--        \u2192 $['count']--\n  //   $count++        \u2192 $['count']++\n  //   $count += 5     \u2192 $['count'] += 5\n  //   $foo = 5        \u2192 $['foo'] = 5\n  //   $foo.bar        \u2192 $['foo']['bar']\n  //   $foo-bar        \u2192 $['foo-bar']\n  //   $foo.bar-baz    \u2192 $['foo']['bar-baz']\n  //   $foo-$bar       \u2192 $['foo']-$['bar']\n  //   $arr[$index]    \u2192 $['arr'][$['index']]\n  //   $['foo']        \u2192 $['foo']\n  //   $foo[obj.bar]   \u2192 $['foo'][obj.bar]\n  //   $foo['bar.baz'] \u2192 $['foo']['bar.baz']\n  //   $1              \u2192 $['1']\n  //   $123            \u2192 $['123']\n  //   $foo.0.name     \u2192 $['foo']['0']['name']\n  //   $foo.0.1.2.bar.0 \u2192 $['foo']['0']['1']['2']['bar']['0']\n\n  // Transform all signal patterns\n  expr = expr\n    // $['x'] \u2192 $x (normalize existing bracket notation)\n    .replace(/\\$\\['([a-zA-Z_$\\d][\\w$]*)'\\]/g, '$$$1')\n    // $x \u2192 $['x'] (including dots and hyphens)\n    .replace(/\\$([a-zA-Z_\\d]\\w*(?:[.-]\\w+)*)/g, (_, signalName) => {\n      const parts = signalName.split('.')\n      return parts.reduce(\n        (acc: string, part: string) => `${acc}['${part}']`,\n        '$',\n      )\n    })\n    // $ inside brackets: [$x] \u2192 [$['x']]\n    .replace(\n      /\\[(\\$[a-zA-Z_\\d]\\w*)\\]/g,\n      (_, varName) => `[$['${varName.slice(1)}']]`,\n    )\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  let counter = 0\n  for (const match of expr.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = `dsEscaped${counter++}`\n    escaped.set(v, k)\n    expr = expr.replace(DSP + k + DSS, v)\n  }\n\n  const nameGen = (prefix: string, name: string) => {\n    return `${prefix}${snake(name).replaceAll(/\\./g, '_')}`\n  }\n\n  // Replace any action calls\n  const actionsCalled = new Set<string>()\n  const actionsRe = RegExp(`@(${Object.keys(actions).join('|')})\\\\(`, 'gm')\n  const actionMatches = [...expr.matchAll(actionsRe)]\n  const actionNames = new Set<string>()\n  const actionFns = new Set<(...args: any[]) => any>()\n  if (actionMatches.length) {\n    const actionPrefix = `${DATASTAR}Act_`\n    for (const match of actionMatches) {\n      const actionName = match[1]\n      const action = actions[actionName]\n      if (!action) {\n        continue\n      }\n      actionsCalled.add(actionName)\n\n      const name = nameGen(actionPrefix, actionName)\n\n      // Add ctx to action calls\n      expr = expr.replace(`@${actionName}(`, `${name}(`)\n      actionNames.add(name)\n      actionFns.add((...args: any[]) => action.fn(ctx, ...args))\n    }\n  }\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    expr = expr.replace(k, v)\n  }\n\n  ctx.fnContent = expr\n\n  try {\n    const fn = Function(\n      'el',\n      '$',\n      ...(attrPlugin?.argNames || []),\n      ...actionNames,\n      expr,\n    )\n    return (...args: any[]) => {\n      try {\n        return fn(ctx.el, root, ...args, ...actionFns)\n      } catch (e: any) {\n        throw ctx.runtimeErr('ExecuteExpression', {\n          error: e.message,\n        })\n      }\n    }\n  } catch (error: any) {\n    throw ctx.runtimeErr('GenerateExpression', {\n      error: error.message,\n    })\n  }\n}\n", "// Icon: ion:eye\n// Slug: Access signals without subscribing to changes.\n// Description: Allows accessing signals without subscribing to their changes in expressions.\n\nimport type { ActionPlugin } from '../../engine/types'\n\nexport const Peek: ActionPlugin = {\n  type: 'action',\n  name: 'peek',\n  fn: ({ peek }, fn: () => any) => {\n    return peek(fn)\n  },\n}\n", "// Icon: ion:checkmark-round\n// Slug: Sets the value of all matching signals.\n// Description: Sets the value of all matching signals (or all signals if no filter is used) to the expression provided in the first argument.\n\nimport type {\n  ActionPlugin,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../engine/types'\nimport { updateLeaves } from '../../utils/paths'\n\nexport const SetAll: ActionPlugin = {\n  type: 'action',\n  name: 'setAll',\n  fn: (\n    { filtered, mergePatch, peek }: RuntimeContext,\n    value: any,\n    filter: SignalFilterOptions,\n  ) => {\n    peek(() => {\n      const masked = filtered(filter)\n      updateLeaves(masked, () => value)\n      mergePatch(masked)\n    })\n  },\n}\n", "// Icon: material-symbols:toggle-off\n// Slug: Toggles the value of all matching signals.\n// Description: Toggles the boolean value of all matching signals (or all signals if no filter is used).\n\nimport type {\n  ActionPlugin,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../engine/types'\nimport { updateLeaves } from '../../utils/paths'\n\nexport const ToggleAll: ActionPlugin = {\n  type: 'action',\n  name: 'toggleAll',\n  fn: (\n    { filtered, mergePatch, peek }: RuntimeContext,\n    filter: SignalFilterOptions,\n  ) => {\n    peek(() => {\n      const masked = filtered(filter)\n      updateLeaves(masked, (oldValue: any) => !oldValue)\n      mergePatch(masked)\n    })\n  },\n}\n", "// Icon: material-symbols:edit-attributes-outline\n// Slug: Syncs the value of an attribute with an expression.\n// Description: Sets the value of any HTML attribute to an expression, and keeps it in sync.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { kebab } from '../../utils/text'\n\nexport const Attr: AttributePlugin = {\n  type: 'attribute',\n  name: 'attr',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ el, effect, key, rx }) => {\n    const syncAttr = (key: string, val: any) => {\n      if (val === '' || val === true) {\n        el.setAttribute(key, '')\n      } else if (val === false || val == null) {\n        el.removeAttribute(key)\n      } else if (typeof val === 'string') {\n        el.setAttribute(key, val)\n      } else {\n        el.setAttribute(key, JSON.stringify(val))\n      }\n    }\n\n    key = kebab(key)\n    const update = key\n      ? () => {\n          observer.disconnect()\n          const val = rx<string>()\n          syncAttr(key, val)\n          observer.observe(el, {\n            attributeFilter: [key],\n          })\n        }\n      : () => {\n          observer.disconnect()\n          const obj = rx<Record<string, any>>()\n          const attributeFilter = Object.keys(obj)\n          for (const key of attributeFilter) {\n            syncAttr(key, obj[key])\n          }\n          observer.observe(el, {\n            attributeFilter,\n          })\n        }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "// Icon: akar-icons:link-chain\n// Slug: Creates a signal with two-way data binding.\n// Description: Creates a signal (if one doesn\u2019t already exist) and sets up two-way data binding between it and an element\u2019s value.\n\nimport { aliasify } from '../../engine/engine'\nimport type { AttributePlugin, Paths } from '../../engine/types'\nimport { modifyCasing } from '../../utils/text'\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst empty = Symbol('empty')\n\nexport const Bind: AttributePlugin = {\n  type: 'attribute',\n  name: 'bind',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  shouldEvaluate: false,\n  onLoad: ({\n    el,\n    key,\n    mods,\n    value,\n    effect,\n    mergePaths,\n    runtimeErr,\n    getPath,\n  }) => {\n    const signalName = key ? modifyCasing(key, mods) : value\n\n    let get = (el: any, type: string) =>\n      type === 'number' ? +el.value : el.value\n\n    let set = (value: any) => {\n      ;(el as HTMLInputElement).value = `${value}`\n    }\n\n    if (el instanceof HTMLInputElement) {\n      switch (el.type) {\n        case 'range':\n        case 'number':\n          get = (el: any, type: string) =>\n            type === 'string' ? el.value : +el.value\n          break\n\n        case 'checkbox':\n          get = (el: HTMLInputElement, type: string) => {\n            if (el.value !== 'on') {\n              if (type === 'boolean') {\n                return el.checked\n              } else {\n                return el.checked ? el.value : ''\n              }\n            } else {\n              if (type === 'string') {\n                return el.checked ? el.value : ''\n              } else {\n                return el.checked\n              }\n            }\n          }\n          set = (value: string | boolean) => {\n            el.checked = typeof value === 'string' ? value === el.value : value\n          }\n          break\n\n        case 'radio':\n          // Set up radio button name attribute if not present\n          if (!el.getAttribute('name')?.length) {\n            el.setAttribute('name', signalName)\n          }\n\n          get = (el: HTMLInputElement, type: string) =>\n            el.checked ? (type === 'number' ? +el.value : el.value) : empty\n          set = (value: string | number) => {\n            el.checked =\n              value === (typeof value === 'number' ? +el.value : el.value)\n          }\n          break\n        case 'file': {\n          const syncSignal = () => {\n            const files = [...(el.files || [])]\n            const contents: string[] = []\n            const mimes: string[] = []\n            const names: string[] = []\n            Promise.all(\n              files.map(\n                (f) =>\n                  new Promise<void>((resolve) => {\n                    const reader = new FileReader()\n                    reader.onload = () => {\n                      if (typeof reader.result !== 'string') {\n                        throw runtimeErr('InvalidFileResultType', {\n                          resultType: typeof reader.result,\n                        })\n                      }\n                      const match = reader.result.match(dataURIRegex)\n                      if (!match?.groups) {\n                        throw runtimeErr('InvalidDataUri', {\n                          result: reader.result,\n                        })\n                      }\n                      contents.push(match.groups.contents)\n                      mimes.push(match.groups.mime)\n                      names.push(f.name)\n                    }\n                    reader.onloadend = () => resolve()\n                    reader.readAsDataURL(f)\n                  }),\n              ),\n            ).then(() => {\n              mergePaths([\n                [signalName, contents],\n                [`${signalName}Mimes`, mimes],\n                [`${signalName}Names`, names],\n              ])\n            })\n          }\n\n          el.addEventListener('change', syncSignal)\n          el.addEventListener('input', syncSignal)\n\n          return () => {\n            el.removeEventListener('change', syncSignal)\n            el.removeEventListener('input', syncSignal)\n          }\n        }\n      }\n    } else if (el instanceof HTMLSelectElement) {\n      if (el.multiple) {\n        const typeMap = new Map<string, string>()\n        get = (el: HTMLSelectElement) =>\n          [...el.selectedOptions].map((option) => {\n            const type = typeMap.get(option.value)\n            return type === 'string' || type == null\n              ? option.value\n              : +option.value\n          })\n\n        set = (value: (string | number)[]) => {\n          for (const option of el.options) {\n            if (value.includes(option.value)) {\n              typeMap.set(option.value, 'string')\n              option.selected = true\n            } else if (value.includes(+option.value)) {\n              typeMap.set(option.value, 'number')\n              option.selected = true\n            } else {\n              option.selected = false\n            }\n          }\n        }\n      }\n    } else if (el instanceof HTMLTextAreaElement) {\n      // default case\n    } else {\n      // web component\n      get = (el: Element) =>\n        'value' in el ? el.value : el.getAttribute('value')\n      set = (value: any) => {\n        if ('value' in el) {\n          el.value = value\n        } else {\n          el.setAttribute('value', value)\n        }\n      }\n    }\n\n    const initialValue = getPath(signalName)\n    const type = typeof initialValue\n\n    let path = signalName\n    if (\n      Array.isArray(initialValue) &&\n      !(el instanceof HTMLSelectElement && el.multiple)\n    ) {\n      const inputs = document.querySelectorAll(\n        `[${aliasify('bind')}-${key}],[${aliasify('bind')}=\"${value}\"]`,\n      ) as NodeListOf<HTMLInputElement>\n\n      const paths: Paths = []\n      let i = 0\n      for (const input of inputs) {\n        paths.push([`${path}.${i}`, get(input, 'none')])\n\n        if (el === input) {\n          break\n        }\n        i++\n      }\n      mergePaths(paths, { ifMissing: true })\n      path = `${path}.${i}`\n    } else {\n      mergePaths([[path, get(el, type)]], {\n        ifMissing: true,\n      })\n    }\n\n    const syncSignal = () => {\n      const signalValue = getPath(path)\n      if (signalValue != null) {\n        const value = get(el, typeof signalValue)\n        if (value !== empty) {\n          mergePaths([[path, value]])\n        }\n      }\n    }\n\n    el.addEventListener('input', syncSignal)\n    el.addEventListener('change', syncSignal)\n    const cleanup = effect(() => {\n      set(getPath(path))\n    })\n\n    return () => {\n      cleanup()\n      el.removeEventListener('input', syncSignal)\n      el.removeEventListener('change', syncSignal)\n    }\n  },\n}\n", "// Icon: ic:baseline-format-paint\n// Slug: Adds or removes a class based on an expression.\n// Description: Adds or removes a class to or from an element based on an expression.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { kebab, modifyCasing } from '../../utils/text'\n\nexport const Class: AttributePlugin = {\n  type: 'attribute',\n  name: 'class',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ key, el, effect, mods, rx }) => {\n    if (key) {\n      key = modifyCasing(kebab(key), mods)\n    }\n\n    const callback = () => {\n      observer.disconnect()\n\n      const classes = key\n        ? { [key]: rx<boolean>() }\n        : rx<Record<string, boolean>>()\n\n      for (const k in classes) {\n        const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n        if (classes[k]) {\n          for (const name of classNames) {\n            if (!el.classList.contains(name)) {\n              el.classList.add(name)\n            }\n          }\n        } else {\n          for (const name of classNames) {\n            if (el.classList.contains(name)) {\n              el.classList.remove(name)\n            }\n          }\n        }\n      }\n\n      observer.observe(el, { attributeFilter: ['class'] })\n    }\n\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n\n      const classes = key\n        ? { [key]: rx<boolean>() }\n        : rx<Record<string, boolean>>()\n\n      for (const k in classes) {\n        const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n        for (const name of classNames) {\n          el.classList.remove(name)\n        }\n      }\n    }\n  },\n}\n", "// Icon: streamline-ultimate:wifi-signal-2\n// Slug: Creates a computed signal.\n// Description: Creates a signal that is computed based on an expression.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { modifyCasing } from '../../utils/text'\n\nexport const Computed: AttributePlugin = {\n  type: 'attribute',\n  name: 'computed',\n  keyReq: 'must',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ key, mods, rx, computed, mergePaths }) => {\n    mergePaths([[modifyCasing(key, mods), computed(rx)]])\n  },\n}\n", "// Icon: oui:security-signal\n// Slug: Executes an expression when signals change.\n// Description: Executes an expression on page load and whenever any signals in the expression change.\n\nimport type { AttributePlugin } from '../../engine/types'\n\nexport const Effect: AttributePlugin = {\n  type: 'attribute',\n  name: 'effect',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ effect, rx }) => effect(rx),\n}\n", "import { DATASTAR } from '../../engine/consts'\nimport type { HTMLOrSVG } from '../../engine/types'\n\nexport const DATASTAR_FETCH_EVENT = `${DATASTAR}-fetch`\nexport const STARTED = 'started'\nexport const FINISHED = 'finished'\nexport const ERROR = 'error'\nexport const RETRYING = 'retrying'\nexport const RETRIES_FAILED = 'retries-failed'\n\nexport interface DatastarFetchEvent {\n  type: string\n  el: HTMLOrSVG\n  argsRaw: Record<string, string>\n}\n\nexport interface CustomEventMap {\n  [DATASTAR_FETCH_EVENT]: CustomEvent<DatastarFetchEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\n\ndeclare global {\n  interface Document {\n    //adds definition to Document, but you can do the same with HTMLElement\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n  }\n}\n\nexport function datastarSSEEventWatcher(\n  eventType: string,\n  fn: (argsRaw: Record<string, string>) => void,\n) {\n  document.addEventListener(\n    DATASTAR_FETCH_EVENT,\n    (event: CustomEvent<DatastarFetchEvent>) => {\n      if (event.detail.type === eventType) {\n        const { argsRaw } = event.detail\n        fn(argsRaw)\n      }\n    },\n  )\n}\n", "// Icon: streamline:signal-loading-remix\n// Slug: Creates an indicator for whether an SSE request is in flight.\n// Description: Creates a signal and sets its value to `true` while an SSE request request is in flight, otherwise `false`.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { modifyCasing } from '../../utils/text'\nimport {\n  DATASTAR_FETCH_EVENT,\n  type DatastarFetchEvent,\n  FINISHED,\n  STARTED,\n} from '../backend/shared'\n\nexport const Indicator: AttributePlugin = {\n  type: 'attribute',\n  name: 'indicator',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  shouldEvaluate: false,\n  onLoad: ({ el, key, mods, mergePaths, value }) => {\n    const signalName = key ? modifyCasing(key, mods) : value\n\n    mergePaths([[signalName, false]], { ifMissing: true })\n\n    const watcher = ((event: CustomEvent<DatastarFetchEvent>) => {\n      const { type, el: elt } = event.detail\n      if (elt !== el) {\n        return\n      }\n      switch (type) {\n        case STARTED:\n          mergePaths([[signalName, true]])\n          break\n        case FINISHED:\n          mergePaths([[signalName, false]])\n          break\n      }\n    }) as EventListener\n    document.addEventListener(DATASTAR_FETCH_EVENT, watcher)\n    return () => {\n      mergePaths([[signalName, false]])\n      document.removeEventListener(DATASTAR_FETCH_EVENT, watcher)\n    }\n  },\n}\n", "// Icon: si:json-fill\n// Slug: Outputs a JSON stringified version of signals.\n// Description: Sets the text content of an element to a reactive JSON stringified version of signals.\n\nimport type { AttributePlugin, SignalFilterOptions } from '../../engine/types'\nimport { jsStrToObject } from '../../utils/text'\n\nexport const JsonSignals: AttributePlugin = {\n  type: 'attribute',\n  name: 'jsonSignals',\n  keyReq: 'denied',\n  onLoad: ({ el, effect, value, filtered, mods }) => {\n    const spaces = mods.has('terse') ? 0 : 2\n    let filters: SignalFilterOptions = {}\n    if (value) {\n      filters = jsStrToObject(value)\n    }\n\n    const callback = () => {\n      observer.disconnect()\n      el.textContent = JSON.stringify(filtered(filters), null, spaces)\n      observer.observe(el, {\n        childList: true,\n        characterData: true,\n        subtree: true,\n      })\n    }\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "export function tagToMs(args: Set<string>) {\n  if (!args || args.size <= 0) return 0\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return +arg.replace('ms', '')\n    }\n    if (arg.endsWith('s')) {\n      return +arg.replace('s', '') * 1000\n    }\n    try {\n      return Number.parseFloat(arg)\n    } catch (_) {}\n  }\n  return 0\n}\n\nexport function tagHas(tags: Set<string>, tag: string, defaultValue = false) {\n  if (!tags) return defaultValue\n  return tags.has(tag.toLowerCase())\n}\n\nexport function tagFirst(tags?: Set<string>, defaultValue = ''): string {\n  if (tags && tags.size > 0) {\n    for (const tag of tags) {\n      return tag\n    }\n  }\n  return defaultValue\n}\n", "import type { EventCallbackHandler, Modifiers } from '../engine/types'\nimport { tagHas, tagToMs } from './tags'\n\nexport function delay(\n  callback: EventCallbackHandler,\n  wait: number,\n): EventCallbackHandler {\n  return (...args: any[]) => {\n    setTimeout(() => {\n      callback(...args)\n    }, wait)\n  }\n}\n\nexport function debounce(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = false,\n  trailing = true,\n): EventCallbackHandler {\n  let timer = 0\n  return (...args: any[]) => {\n    timer && clearTimeout(timer)\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      timer && clearTimeout(timer)\n    }, wait)\n  }\n}\n\nexport function throttle(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n): EventCallbackHandler {\n  let waiting = false\n\n  return (...args: any[]) => {\n    if (waiting) return\n\n    if (leading) {\n      callback(...args)\n    }\n\n    waiting = true\n    setTimeout(() => {\n      waiting = false\n      if (trailing) {\n        callback(...args)\n      }\n    }, wait)\n  }\n}\n\nexport function modifyTiming(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  const delayArgs = mods.get('delay')\n  if (delayArgs) {\n    const wait = tagToMs(delayArgs)\n    callback = delay(callback, wait)\n  }\n\n  const debounceArgs = mods.get('debounce')\n  if (debounceArgs) {\n    const wait = tagToMs(debounceArgs)\n    const leading = tagHas(debounceArgs, 'leading', false)\n    const trailing = !tagHas(debounceArgs, 'notrail', false)\n    callback = debounce(callback, wait, leading, trailing)\n  }\n\n  const throttleArgs = mods.get('throttle')\n  if (throttleArgs) {\n    const wait = tagToMs(throttleArgs)\n    const leading = !tagHas(throttleArgs, 'noleading', false)\n    const trailing = tagHas(throttleArgs, 'trail', false)\n    callback = throttle(callback, wait, leading, trailing)\n  }\n\n  return callback\n}\n", "import type { EventCallbackHandler, Modifiers } from '../engine/types'\n\nexport interface DocumentSupportingViewTransitionAPI {\n  startViewTransition(\n    updateCallback: () => Promise<void> | void,\n  ): IViewTransition\n}\n\nexport interface IViewTransition {\n  finished: Promise<void>\n  ready: Promise<void>\n  updateCallbackDone: Promise<void>\n  skipTransition(): void\n}\n\nexport const supportsViewTransitions = !!document.startViewTransition\n\nexport function modifyViewTransition(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  if (mods.has('viewtransition') && supportsViewTransitions) {\n    const cb = callback // I hate javascript\n    callback = (...args: any[]) =>\n      document.startViewTransition(() => cb(...args))\n  }\n\n  return callback\n}\n", "// Icon: material-symbols:mail\n// Slug: Attaches an event listener to an element.\n// Description: Attaches an event listener to an element, executing an expression whenever the event is triggered.\n\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_PATCH_EVENT,\n} from '../../engine/types'\nimport { kebab, modifyCasing } from '../../utils/text'\nimport { modifyTiming } from '../../utils/timing'\nimport { modifyViewTransition } from '../../utils/view-transitions'\nimport { DATASTAR_FETCH_EVENT } from '../backend/shared'\n\nexport const On: AttributePlugin = {\n  type: 'attribute',\n  name: 'on',\n  keyReq: 'must',\n  valReq: 'must',\n  argNames: ['evt'],\n  onLoad: (ctx) => {\n    const { el, key, mods, rx, startBatch, endBatch } = ctx\n    let target: Element | Window | Document = el\n    if (mods.has('window')) target = window\n    let callback = (evt?: Event) => {\n      if (evt) {\n        if (mods.has('prevent')) {\n          evt.preventDefault()\n        }\n        if (mods.has('stop')) {\n          evt.stopPropagation()\n        }\n        ctx.evt = evt\n      }\n      startBatch()\n      rx(evt)\n      endBatch()\n    }\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n    const evtListOpts: AddEventListenerOptions = {\n      capture: mods.has('capture'),\n      passive: mods.has('passive'),\n      once: mods.has('once'),\n    }\n    if (mods.has('outside')) {\n      target = document\n      const cb = callback\n      callback = (evt?: Event) => {\n        if (!el.contains(evt?.target as HTMLElement)) {\n          cb(evt)\n        }\n      }\n    }\n    // Default to kebab-case and allow modifying\n    let eventName = kebab(key)\n    eventName = modifyCasing(eventName, mods)\n    // Listen for Datastar events on the document\n    if (\n      eventName === DATASTAR_FETCH_EVENT ||\n      eventName === DATASTAR_SIGNAL_PATCH_EVENT\n    ) {\n      target = document\n    }\n    // Prevent default on form submit events\n    if (el instanceof HTMLFormElement && eventName === 'submit') {\n      const cb = callback\n      callback = (evt?: Event) => {\n        evt?.preventDefault()\n        cb(evt)\n      }\n    }\n    target.addEventListener(eventName, callback, evtListOpts)\n    return () => {\n      target.removeEventListener(eventName, callback)\n    }\n  },\n}\n", "// Icon: mdi-light:vector-intersection\n// Slug: Runs an expression on intersection.\n// Description: Runs an expression when the element intersects with the viewport.\n\nimport type { AttributePlugin, HTMLOrSVG } from '../../engine/types'\nimport { modifyTiming } from '../../utils/timing'\nimport { modifyViewTransition } from '../../utils/view-transitions'\n\nconst once = new WeakSet<HTMLOrSVG>()\n\nexport const OnIntersect: AttributePlugin = {\n  type: 'attribute',\n  name: 'onIntersect',\n  keyReq: 'denied',\n  onLoad: ({ el, mods, rx, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n    const options = { threshold: 0 }\n    if (mods.has('full')) {\n      options.threshold = 1\n    } else if (mods.has('half')) {\n      options.threshold = 0.5\n    }\n    let observer: IntersectionObserver | null = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          if (entry.isIntersecting) {\n            callback()\n            if (observer && once.has(el)) {\n              observer.disconnect()\n            }\n          }\n        }\n      },\n      options,\n    )\n    observer.observe(el)\n    if (mods.has('once')) {\n      once.add(el)\n    }\n    return () => {\n      if (!mods.has('once')) {\n        once.delete(el)\n      }\n      if (observer) {\n        observer.disconnect()\n        observer = null\n      }\n    }\n  },\n}\n", "// Icon: material-symbols:timer-outline\n// Slug: Runs an expression at a regular interval.\n// Description: Runs an expression at a regular interval.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { tagHas, tagToMs } from '../../utils/tags'\nimport { modifyViewTransition } from '../../utils/view-transitions'\n\nexport const OnInterval: AttributePlugin = {\n  type: 'attribute',\n  name: 'onInterval',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ mods, rx, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let duration = 1000\n    const durationArgs = mods.get('duration')\n    if (durationArgs) {\n      duration = tagToMs(durationArgs)\n      const leading = tagHas(durationArgs, 'leading', false)\n      if (leading) {\n        callback()\n      }\n    }\n    const intervalId = setInterval(callback, duration)\n    return () => {\n      clearInterval(intervalId)\n    }\n  },\n}\n", "// Icon: material-symbols:timer-play-outline\n// Slug: Runs an expression when loaded into the DOM.\n// Description: Runs an expression when the element is loaded into the DOM.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { tagToMs } from '../../utils/tags'\nimport { delay } from '../../utils/timing'\nimport { modifyViewTransition } from '../../utils/view-transitions'\n\nexport const OnLoad: AttributePlugin = {\n  type: 'attribute',\n  name: 'onLoad',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ rx, mods, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let wait = 0\n    const delayArgs = mods.get('delay')\n    if (delayArgs) {\n      wait = tagToMs(delayArgs)\n      if (wait > 0) {\n        callback = delay(callback, wait)\n      }\n    }\n    callback()\n  },\n}\n", "// Icon: material-symbols:change-circle-outline\n// Slug: Runs an expression when signals are patched.\n// Description: Runs an expression whenever one or more signals are patched.\n\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_PATCH_EVENT,\n  type JSONPatch,\n  type SignalFilterOptions,\n} from '../../engine/types'\nimport { isEmpty } from '../../utils/paths'\nimport { jsStrToObject } from '../../utils/text'\nimport { modifyTiming } from '../../utils/timing'\n\nexport const OnSignalPatch: AttributePlugin = {\n  type: 'attribute',\n  name: 'onSignalPatch',\n  valReq: 'must',\n  argNames: ['patch'],\n  returnsValue: true,\n  onLoad: ({\n    el,\n    key,\n    mods,\n    plugin,\n    rx,\n    filtered,\n    runtimeErr,\n    startBatch,\n    endBatch,\n  }) => {\n    // Throw an error if the key exists and is not `filter`\n    if (!!key && key !== 'filter') {\n      throw runtimeErr(`${plugin.name}KeyNotAllowed`)\n    }\n\n    // Look for data-on-signal-patch-filter data attribute\n    const filtersRaw = el.getAttribute('data-on-signal-patch-filter')\n    let filters: SignalFilterOptions = {}\n    if (filtersRaw) {\n      filters = jsStrToObject(filtersRaw)\n    }\n\n    const callback: EventListener = modifyTiming(\n      (evt: CustomEvent<JSONPatch>) => {\n        const watched = filtered(filters, evt.detail)\n        if (!isEmpty(watched)) {\n          startBatch()\n          rx(watched)\n          endBatch()\n        }\n      },\n      mods,\n    )\n\n    document.addEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback)\n    return () => {\n      document.removeEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback)\n    }\n  },\n}\n", "// Icon: mdi:cursor-pointer\n// Slug: Creates a reference to an element.\n// Description: Creates a new signal that is a reference to the element on which the data attribute is placed.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { modifyCasing } from '../../utils/text'\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n  type: 'attribute',\n  name: 'ref',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  shouldEvaluate: false,\n  onLoad: ({ el, key, mods, value, mergePaths }) => {\n    const signalName = key ? modifyCasing(key, mods) : value\n    mergePaths([[signalName, el]])\n  },\n}\n", "// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Shows or hides an element.\n// Description: Shows or hides an element based on whether an expression evaluates to `true` or `false`.\n\nimport type { AttributePlugin } from '../../engine/types'\n\nconst NONE = 'none'\nconst DISPLAY = 'display'\n\nexport const Show: AttributePlugin = {\n  type: 'attribute',\n  name: 'show',\n  keyReq: 'denied',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ el, effect, rx }) => {\n    const update = () => {\n      observer.disconnect()\n      const shouldShow = rx()\n      if (shouldShow) {\n        if (el.style.display === NONE) el.style.removeProperty(DISPLAY)\n      } else {\n        el.style.setProperty(DISPLAY, NONE)\n      }\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "// Icon: streamline:wifi-signal-full-remix\n// Slug: Patches signals into the existing signals.\n// Description: Patches (adds, updates or removes) one or more signals into the existing signals.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { modifyCasing } from '../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: 'attribute',\n  name: 'signals',\n  returnsValue: true,\n  onLoad: ({ key, mods, rx, mergePatch, mergePaths }) => {\n    const ifMissing = mods.has('ifmissing')\n\n    if (key) {\n      key = modifyCasing(key, mods)\n      mergePaths([[key, rx()]], { ifMissing })\n    } else {\n      const patch = Object.assign({}, rx<Record<string, any>>())\n      mergePatch(patch, { ifMissing })\n    }\n  },\n}\n", "// Icon: material-symbols:format-paint-outline\n// Slug: Sets inline styles on an element based on an expression.\n// Description: Sets CSS styles on an element using either key-based or object syntax, and keeps them in sync with reactive signals.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { kebab } from '../../utils/text'\n\nexport const Style: AttributePlugin = {\n  type: 'attribute',\n  name: 'style',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ key, el, effect, rx }) => {\n    const { style } = el\n    const initialStyles = new Map<string, string>()\n\n    key &&= kebab(key)\n\n    const apply = (prop: string, value: any) => {\n      const initial = initialStyles.get(prop)\n      if (!value && value !== 0) {\n        initial !== undefined &&\n          (initial\n            ? style.setProperty(prop, initial)\n            : style.removeProperty(prop))\n      } else {\n        initial === undefined &&\n          initialStyles.set(prop, style.getPropertyValue(prop))\n        style.setProperty(prop, String(value))\n      }\n    }\n\n    const update = () => {\n      observer.disconnect()\n\n      if (key) {\n        apply(key, rx())\n      } else {\n        const styles = rx<Record<string, any>>()\n\n        for (const [prop, initial] of initialStyles) {\n          prop in styles ||\n            (initial\n              ? style.setProperty(prop, initial)\n              : style.removeProperty(prop))\n        }\n\n        for (const prop in styles) {\n          apply(kebab(prop), styles[prop])\n        }\n      }\n\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n      for (const [prop, initial] of initialStyles) {\n        initial ? style.setProperty(prop, initial) : style.removeProperty(prop)\n      }\n    }\n  },\n}\n", "// Icon: icon-park-outline:text\n// Slug: Binds the text content of an element.\n// Description: Binds the text content of an element to an expression.\n\nimport type { AttributePlugin } from '../../engine/types'\n\nexport const Text: AttributePlugin = {\n  type: 'attribute',\n  name: 'text',\n  keyReq: 'denied',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ el, effect, rx }) => {\n    const update = () => {\n      observer.disconnect()\n      el.textContent = `${rx()}`\n      observer.observe(el, {\n        childList: true,\n        characterData: true,\n        subtree: true,\n      })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "import {\n  DATASTAR,\n  DATASTAR_REQUEST,\n  DefaultSseRetryDurationMs,\n  EventTypePatchElements,\n  EventTypePatchSignals,\n} from '../../../engine/consts'\n// Factory for creating HTTP method action plugins\nimport type {\n  ActionPlugin,\n  HTMLOrSVG,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../../engine/types'\nimport { kebab } from '../../../utils/text'\nimport {\n  DATASTAR_FETCH_EVENT,\n  type DatastarFetchEvent,\n  ERROR,\n  FINISHED,\n  RETRIES_FAILED,\n  RETRYING,\n  STARTED,\n} from '../shared'\n\n// Global store for active SSE controllers per element\nconst fetchAbortControllers = new WeakMap<HTMLOrSVG, AbortController>()\n\n// Helper to create HTTP method plugins with consistent structure\nexport const createHttpMethod = (\n  name: string,\n  method: string,\n): ActionPlugin => ({\n  type: 'action',\n  name,\n  fn: async (ctx, url: string, args: FetchArgs) => {\n    const { el } = ctx\n\n    const requestCancellation = args?.requestCancellation ?? 'auto'\n    const controller =\n      requestCancellation instanceof AbortController\n        ? requestCancellation\n        : new AbortController()\n    const isDisabled = requestCancellation === 'disabled'\n    if (!isDisabled) {\n      fetchAbortControllers.get(el)?.abort()\n    }\n\n    if (!isDisabled && !(requestCancellation instanceof AbortController)) {\n      fetchAbortControllers.set(el, controller)\n    }\n\n    try {\n      await fetcher(ctx, method, url, args, controller.signal)\n    } finally {\n      if (fetchAbortControllers.get(el) === controller) {\n        fetchAbortControllers.delete(el)\n      }\n    }\n  },\n})\n\nconst dispatchFetch = (\n  type: string,\n  el: HTMLOrSVG,\n  argsRaw: Record<string, string>,\n) =>\n  document.dispatchEvent(\n    new CustomEvent<DatastarFetchEvent>(DATASTAR_FETCH_EVENT, {\n      detail: { type, el, argsRaw },\n    }),\n  )\n\nconst isWrongContent = (err: any) => `${err}`.includes('text/event-stream')\n\ntype ResponseOverrides =\n  | {\n      selector?: string\n      mode?: string\n      useViewTransition?: boolean\n    }\n  | {\n      onlyIfMissing?: boolean\n    }\n\nexport type FetchArgs = {\n  headers?: Record<string, string>\n  openWhenHidden?: boolean\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  responseOverrides?: ResponseOverrides\n  contentType?: 'json' | 'form'\n  filterSignals?: SignalFilterOptions\n  selector?: string\n  requestCancellation?: 'auto' | 'disabled' | AbortController\n}\n\nconst fetcher = async (\n  { el, evt, filtered, runtimeErr }: RuntimeContext,\n  method: string,\n  url: string,\n  {\n    selector,\n    headers: userHeaders,\n    contentType = 'json',\n    filterSignals: { include = /.*/, exclude = /(^|\\.)_/ } = {},\n    openWhenHidden = false,\n    retryInterval = DefaultSseRetryDurationMs,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n  }: FetchArgs = {},\n  abort?: AbortSignal,\n) => {\n  const action = method.toLowerCase()\n  let cleanupFn = () => {}\n  try {\n    if (!url?.length) {\n      throw runtimeErr('FetchNoUrlProvided', { action })\n    }\n\n    const initialHeaders: Record<string, any> = {\n      Accept: 'text/event-stream, text/html, application/json',\n      [DATASTAR_REQUEST]: true,\n    }\n    if (contentType === 'json') {\n      initialHeaders['Content-Type'] = 'application/json'\n    }\n    const headers = Object.assign({}, initialHeaders, userHeaders)\n\n    // We ignore the content-type header if using form data\n    // if missing the boundary will be set automatically\n\n    const req: FetchEventSourceInit = {\n      method,\n      headers,\n      openWhenHidden,\n      retryInterval,\n      retryScaler,\n      retryMaxWaitMs,\n      retryMaxCount,\n      signal: abort,\n      onopen: async (response: Response) => {\n        if (response.status >= 400)\n          dispatchFetch(ERROR, el, { status: response.status.toString() })\n      },\n      onmessage: (evt) => {\n        if (!evt.event.startsWith(DATASTAR)) return\n        const type = evt.event\n        const argsRawLines: Record<string, string[]> = {}\n\n        for (const line of evt.data.split('\\n')) {\n          const i = line.indexOf(' ')\n          const k = line.slice(0, i)\n          const v = line.slice(i + 1)\n          ;(argsRawLines[k] ||= []).push(v)\n        }\n\n        const argsRaw = Object.fromEntries(\n          Object.entries(argsRawLines).map(([k, v]) => [k, v.join('\\n')]),\n        )\n\n        dispatchFetch(type, el, argsRaw)\n      },\n      onerror: (error) => {\n        if (isWrongContent(error)) {\n          // don't retry if the content-type is wrong\n          throw runtimeErr('InvalidContentType', { url })\n        }\n        // do nothing and it will retry\n        if (error) {\n          console.error(error.message)\n          dispatchFetch(RETRYING, el, { message: error.message })\n        }\n      },\n    }\n\n    const urlInstance = new URL(url, window.location.href)\n    const queryParams = new URLSearchParams(urlInstance.search)\n\n    if (contentType === 'json') {\n      const res = JSON.stringify(filtered({ include, exclude }))\n      if (method === 'GET') {\n        queryParams.set(DATASTAR, res)\n      } else {\n        req.body = res\n      }\n    } else if (contentType === 'form') {\n      const formEl = (\n        selector ? document.querySelector(selector) : el.closest('form')\n      ) as HTMLFormElement\n      if (!formEl) {\n        throw runtimeErr(\n          selector ? 'FetchFormNotFound' : 'FetchClosestFormNotFound',\n          { action, selector },\n        )\n      }\n\n      // Validate the form\n      if (!formEl.checkValidity()) {\n        formEl.reportValidity()\n        cleanupFn()\n        return\n      }\n\n      // Collect the form data\n\n      const formData = new FormData(formEl)\n      let submitter = el as HTMLElement | null\n\n      if (el === formEl && evt instanceof SubmitEvent) {\n        // Get the submitter from the event\n        submitter = evt.submitter\n      } else {\n        // Prevent the form being submitted\n        const preventDefault = (evt: Event) => evt.preventDefault()\n        formEl.addEventListener('submit', preventDefault)\n        cleanupFn = () => formEl.removeEventListener('submit', preventDefault)\n      }\n\n      // Append the value of the form submitter if it is a button with a name\n      if (submitter instanceof HTMLButtonElement) {\n        const name = submitter.getAttribute('name')\n        if (name) formData.append(name, submitter.value)\n      }\n\n      const multipart = formEl.getAttribute('enctype') === 'multipart/form-data'\n      // Leave the `Content-Type` header empty for multipart encoding so the browser can set it automatically with the correct boundary\n      if (!multipart) {\n        headers['Content-Type'] = 'application/x-www-form-urlencoded'\n      }\n\n      const formParams = new URLSearchParams(formData as any)\n      if (method === 'GET') {\n        for (const [key, value] of formParams) {\n          queryParams.append(key, value)\n        }\n      } else if (multipart) {\n        // Upload progress events are only available for: HTTPS connections (required for streaming uploads) with Multipart form data uploads\n        if (__USE_UPLOAD_PROGRESS__ && urlInstance.protocol === 'https:') {\n          const boundary = `----FormDataBoundary${Math.random().toString(36).substring(2, 11)}`\n          const encoder = new TextEncoder()\n\n          // Calculate total size\n          let total = 0\n          const parts: Array<{ field: string; value: string | File }> = []\n\n          for (const [name, value] of formData) {\n            parts.push({ field: name, value })\n            total += encoder.encode(`--${boundary}\\r\\n`).byteLength\n\n            if (value instanceof File) {\n              total += encoder.encode(\n                `Content-Disposition: form-data; name=\"${name}\"; filename=\"${value.name}\"\\r\\n` +\n                  `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`,\n              ).byteLength\n              total += value.size + 2\n            } else {\n              total += encoder.encode(\n                `Content-Disposition: form-data; name=\"${name}\"\\r\\n\\r\\n${value}\\r\\n`,\n              ).byteLength\n            }\n          }\n          total += encoder.encode(`--${boundary}--\\r\\n`).byteLength\n\n          let loaded = 0\n\n          req.body = new ReadableStream({\n            async start(controller) {\n              const write = (data: Uint8Array) => {\n                controller.enqueue(data)\n                loaded += data.byteLength\n\n                const progress = Math.round((loaded / total) * 100)\n                dispatchFetch('upload-progress', el, {\n                  progress: progress.toString(),\n                  loaded: loaded.toString(),\n                  total: total.toString(),\n                })\n              }\n\n              dispatchFetch('upload-progress', el, {\n                progress: '0',\n                loaded: '0',\n                total: total.toString(),\n              })\n\n              try {\n                for (const { field, value } of parts) {\n                  write(encoder.encode(`--${boundary}\\r\\n`))\n\n                  if (value instanceof File) {\n                    write(\n                      encoder.encode(\n                        `Content-Disposition: form-data; name=\"${field}\"; filename=\"${value.name}\"\\r\\n` +\n                          `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`,\n                      ),\n                    )\n\n                    const reader = value.stream().getReader()\n                    try {\n                      while (true) {\n                        const { done, value: chunk } = await reader.read()\n                        if (done) break\n                        write(chunk)\n                      }\n                    } finally {\n                      reader.releaseLock()\n                    }\n                    write(encoder.encode('\\r\\n'))\n                  } else {\n                    write(\n                      encoder.encode(\n                        `Content-Disposition: form-data; name=\"${field}\"\\r\\n\\r\\n${value}\\r\\n`,\n                      ),\n                    )\n                  }\n                }\n\n                write(encoder.encode(`--${boundary}--\\r\\n`))\n\n                if (loaded < total) {\n                  dispatchFetch('upload-progress', el, {\n                    progress: '100',\n                    loaded: total.toString(),\n                    total: total.toString(),\n                  })\n                }\n\n                controller.close()\n              } catch (error) {\n                controller.error(error)\n              }\n            },\n          })\n\n          // Override content-type header with the boundary\n          headers['Content-Type'] = `multipart/form-data; boundary=${boundary}`\n          // Set duplex mode for streaming uploads\n          ;(req as any).duplex = 'half'\n        } else {\n          req.body = formData\n        }\n      } else {\n        req.body = formParams\n      }\n    } else {\n      throw runtimeErr('FetchInvalidContentType', { action, contentType })\n    }\n\n    dispatchFetch(STARTED, el, {})\n    urlInstance.search = queryParams.toString()\n\n    try {\n      await fetchEventSource(urlInstance.toString(), el, req)\n    } catch (error) {\n      if (!isWrongContent(error)) {\n        throw runtimeErr('FetchFailed', { method, url, error })\n      }\n      // exit gracefully and do nothing if the content-type is wrong\n      // this can happen if the client is sending a request\n      // where no response is expected, and they haven\u2019t\n      // set the content-type to text/event-stream\n    }\n  } finally {\n    dispatchFetch(FINISHED, el, {})\n    cleanupFn()\n  }\n}\n\n// Below originally from https://github.com/Azure/fetch-event-source/blob/main/LICENSE\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\n\ninterface EventSourceMessage {\n  id: string\n  event: string\n  data: string\n  retry?: number\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(\n  stream: ReadableStream<Uint8Array>,\n  onChunk: (arr: Uint8Array) => void,\n): Promise<void> {\n  const reader = stream.getReader()\n  let result = await reader.read()\n  while (!result.done) {\n    onChunk(result.value)\n    result = await reader.read()\n  }\n}\n\nfunction getLines(onLine: (line: Uint8Array, fieldLength: number) => void) {\n  let buffer: Uint8Array | undefined\n  let position: number // current read position\n  let fieldLength: number // length of the `field` portion of the line\n  let discardTrailingNewline = false\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array) {\n    if (!buffer) {\n      buffer = arr\n      position = 0\n      fieldLength = -1\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr)\n    }\n\n    const bufLength = buffer.length\n    let lineStart = 0 // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10) lineStart = ++position // skip to next char\n        discardTrailingNewline = false\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1 // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58: // :\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart\n            }\n            break\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          // biome-ignore lint/suspicious/noFallthroughSwitchClause: intentional fallthrough for CR to LF\n          case 13: // \\r\n            discardTrailingNewline = true\n          case 10: // \\n\n            lineEnd = position\n            break\n        }\n      }\n\n      if (lineEnd === -1) break // Wait for the next arr and then continue parsing\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength)\n      lineStart = position // we're now on the next line\n      fieldLength = -1\n    }\n\n    if (lineStart === bufLength)\n      buffer = undefined // we've finished reading it\n    else if (lineStart) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart)\n      position -= lineStart\n    }\n  }\n}\n\nfunction getMessages(\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void,\n) {\n  let message = newMessage()\n  const decoder = new TextDecoder()\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(line: Uint8Array, fieldLength: number) {\n    if (!line.length) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message)\n      message = newMessage()\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength))\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1)\n      const value = decoder.decode(line.subarray(valueOffset))\n\n      switch (field) {\n        case 'data':\n          message.data = message.data ? `${message.data}\\n${value}` : value\n          break\n        case 'event':\n          message.event = value\n          break\n        case 'id':\n          onId((message.id = value))\n          break\n        case 'retry': {\n          const retry = +value\n          if (!Number.isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry))\n          }\n          break\n        }\n      }\n    }\n  }\n}\n\nconst concat = (a: Uint8Array, b: Uint8Array) => {\n  const res = new Uint8Array(a.length + b.length)\n  res.set(a)\n  res.set(b, a.length)\n  return res\n}\n\nconst newMessage = (): EventSourceMessage => ({\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  data: '',\n  event: '',\n  id: '',\n  retry: undefined,\n})\n\ninterface FetchEventSourceInit extends RequestInit {\n  headers?: Record<string, string>\n  onopen?: (response: Response) => Promise<void>\n  onmessage?: (ev: EventSourceMessage) => void\n  onclose?: () => void\n  onerror?: (err: any) => number | null | undefined | void\n  openWhenHidden?: boolean\n  fetch?: typeof fetch\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  overrides?: ResponseOverrides\n}\n\nfunction fetchEventSource(\n  input: RequestInfo,\n  el: HTMLOrSVG,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    retryInterval = 1_000,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    overrides,\n    ...rest\n  }: FetchEventSourceInit,\n) {\n  return new Promise<void>((resolve, reject) => {\n    // make a copy of the input headers since we may modify it below:\n    const headers: Record<string, string> = {\n      ...inputHeaders,\n    }\n\n    let curRequestController: AbortController\n    function onVisibilityChange() {\n      curRequestController.abort() // close existing request on every visibility change\n      if (!document.hidden) create() // page is now visible again, recreate request.\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange)\n    }\n\n    let retryTimer = 0\n    function dispose() {\n      document.removeEventListener('visibilitychange', onVisibilityChange)\n      window.clearTimeout(retryTimer)\n      curRequestController.abort()\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose()\n      resolve() // don't waste time constructing/logging errors\n    })\n\n    const fetch = inputFetch || window.fetch\n    const onopen = inputOnOpen || (() => {})\n\n    let retries = 0\n    let baseRetryInterval = retryInterval\n    async function create() {\n      curRequestController = new AbortController()\n      try {\n        const response = await fetch(input, {\n          ...rest,\n          headers,\n          signal: curRequestController.signal,\n        })\n\n        // on successful connection, reset the retry logic\n        retries = 0\n        retryInterval = baseRetryInterval\n\n        await onopen(response)\n\n        const dispatchNonSSE = async (\n          dispatchType: string,\n          response: Response,\n          name: string,\n          overrides?: ResponseOverrides,\n          ...argNames: string[]\n        ) => {\n          const argsRaw: Record<string, string> = {\n            [name]: await response.text(),\n          }\n          for (const n of argNames) {\n            let v = response.headers.get(`datastar-${kebab(n)}`)\n            if (overrides) {\n              const o = (overrides as any)[n]\n              if (o) v = typeof o === 'string' ? o : JSON.stringify(o)\n            }\n            if (v) argsRaw[n] = v\n          }\n\n          dispatchFetch(dispatchType, el, argsRaw)\n          dispose()\n          resolve()\n        }\n\n        const ct = response.headers.get('Content-Type')\n        if (ct?.includes('text/html')) {\n          return await dispatchNonSSE(\n            EventTypePatchElements,\n            response,\n            'elements',\n            overrides,\n            'selector',\n            'mode',\n            'useViewTransition',\n          )\n        }\n\n        if (ct?.includes('application/json')) {\n          return await dispatchNonSSE(\n            EventTypePatchSignals,\n            response,\n            'signals',\n            overrides,\n            'onlyIfMissing',\n          )\n        }\n\n        if (ct?.includes('text/javascript')) {\n          const script = document.createElement('script')\n          const scriptAttributesHeader = response.headers.get(\n            'datastar-script-attributes',\n          )\n\n          if (scriptAttributesHeader) {\n            for (const [name, value] of Object.entries(\n              JSON.parse(scriptAttributesHeader),\n            )) {\n              script.setAttribute(name, value as string)\n            }\n          }\n          script.textContent = await response.text()\n          document.head.appendChild(script)\n          dispose()\n          return\n        }\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // signals the id and send it back on the next retry:\n                  headers['last-event-id'] = id\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers['last-event-id']\n                }\n              },\n              (retry) => {\n                baseRetryInterval = retryInterval = retry\n              },\n              onmessage,\n            ),\n          ),\n        )\n\n        onclose?.()\n        dispose()\n        resolve()\n      } catch (err) {\n        if (!curRequestController.signal.aborted) {\n          // if we haven\u2019t aborted the request ourselves:\n          try {\n            // check if we need to retry:\n            const interval: any = onerror?.(err) || retryInterval\n            window.clearTimeout(retryTimer)\n            retryTimer = window.setTimeout(create, interval)\n            retryInterval = Math.min(\n              retryInterval * retryScaler,\n              retryMaxWaitMs,\n            ) // exponential backoff\n            if (++retries >= retryMaxCount) {\n              dispatchFetch(RETRIES_FAILED, el, {})\n              // we should not retry anymore:\n              dispose()\n              reject('Max retries reached.') // Max retries reached, check your server or network connection\n            } else {\n              console.error(\n                `Datastar failed to reach ${input.toString()} retrying in ${interval}ms.`,\n              )\n            }\n          } catch (innerErr) {\n            // we should not retry anymore:\n            dispose()\n            reject(innerErr)\n          }\n        }\n      }\n    }\n\n    create()\n  })\n}\n", "// Icon: material-symbols:delete-outline\n// Slug: Sends a `DELETE` request.\n// Description: Sends a `DELETE` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const DELETE = createHttpMethod('delete', 'DELETE')\n", "// Icon: ic:baseline-get-app\n// Slug: Sends a `GET` request.\n// Description: Sends a `GET` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const GET = createHttpMethod('get', 'GET')\n", "// Icon: fluent:patch-24-filled\n// Slug: Sends a `PATCH` request.\n// Description: Sends a `PATCH` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const PATCH = createHttpMethod('patch', 'PATCH')\n", "// Icon: ri:signpost-fill\n// Slug: Sends a `POST` request.\n// Description: Sends a `POST` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const POST = createHttpMethod('post', 'POST')\n", "// Icon: material-symbols:arrows-input\n// Slug: Sends a `PUT` request.\n// Description: Sends a `PUT` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const PUT = createHttpMethod('put', 'PUT')\n", "// Icon: material-symbols:cloud-download\n// Slug: Patches elements into the DOM.\n// Description: Patches elements into the DOM.\n\nimport {\n  DefaultElementPatchMode,\n  ElementPatchModeAfter,\n  ElementPatchModeAppend,\n  ElementPatchModeBefore,\n  ElementPatchModeInner,\n  ElementPatchModeOuter,\n  ElementPatchModePrepend,\n  ElementPatchModeRemove,\n  ElementPatchModeReplace,\n  EventTypePatchElements,\n} from '../../../engine/consts'\nimport { aliasify } from '../../../engine/engine'\nimport type { InitContext, WatcherPlugin } from '../../../engine/types'\nimport { kebab } from '../../../utils/text'\nimport { supportsViewTransitions } from '../../../utils/view-transitions'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const PatchElements: WatcherPlugin = {\n  type: 'watcher',\n  name: EventTypePatchElements,\n  async onGlobalInit(ctx) {\n    datastarSSEEventWatcher(EventTypePatchElements, (args) => {\n      if (\n        supportsViewTransitions &&\n        args.useViewTransition?.trim() === 'true'\n      ) {\n        document.startViewTransition(() => onPatchElements(ctx, args))\n      } else {\n        onPatchElements(ctx, args)\n      }\n    })\n  },\n}\n\nfunction onPatchElements(\n  ctx: InitContext,\n  {\n    elements = '',\n    selector,\n    mode = DefaultElementPatchMode,\n  }: Record<string, string>,\n) {\n  const { initErr } = ctx\n  const elementsWithSvgsRemoved = elements.replace(\n    /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n    '',\n  )\n  const hasHtml = /<\\/html>/.test(elementsWithSvgsRemoved)\n  const hasHead = /<\\/head>/.test(elementsWithSvgsRemoved)\n  const hasBody = /<\\/body>/.test(elementsWithSvgsRemoved)\n\n  const newDocument = new DOMParser().parseFromString(\n    hasHtml || hasHead || hasBody\n      ? elements\n      : `<body><template>${elements}</template></body>`,\n    'text/html',\n  )\n\n  let newContent = document.createDocumentFragment()\n  if (hasHtml) {\n    newContent.appendChild(newDocument.documentElement)\n  } else if (hasHead && hasBody) {\n    newContent.appendChild(newDocument.head)\n    newContent.appendChild(newDocument.body)\n  } else if (hasHead) {\n    newContent.appendChild(newDocument.head)\n  } else if (hasBody) {\n    newContent.appendChild(newDocument.body)\n  } else {\n    newContent = newDocument.querySelector('template')!.content\n  }\n\n  if (\n    !selector &&\n    (mode === ElementPatchModeOuter || mode === ElementPatchModeReplace)\n  ) {\n    for (const child of newContent.children) {\n      let target: Element\n      if (child instanceof HTMLHtmlElement) {\n        target = document.documentElement\n      } else if (child instanceof HTMLBodyElement) {\n        target = document.body\n      } else if (child instanceof HTMLHeadElement) {\n        target = document.head\n      } else {\n        target = document.getElementById(child.id)!\n        if (!target) {\n          console.error(\n            initErr('NoTargetsFound', {\n              id: child.id,\n            }),\n          )\n          continue\n        }\n      }\n\n      applyToTargets(ctx, mode, child, [target])\n    }\n  } else {\n    const targets = document.querySelectorAll(selector)\n    if (!targets.length) {\n      console.error(\n        initErr('NoTargetsFound', {\n          selector: selector,\n        }),\n      )\n      return\n    }\n\n    applyToTargets(ctx, mode, newContent, targets)\n  }\n}\n\nconst scripts = new WeakSet<HTMLScriptElement>()\nfor (const script of document.querySelectorAll('script')) {\n  scripts.add(script)\n}\n\nfunction execute(target: Element): void {\n  const elScripts =\n    target instanceof HTMLScriptElement\n      ? [target]\n      : target.querySelectorAll('script')\n  for (const old of elScripts) {\n    if (!scripts.has(old)) {\n      const script = document.createElement('script')\n      for (const { name, value } of old.attributes) {\n        script.setAttribute(name, value)\n      }\n      script.text = old.text\n      old.replaceWith(script)\n      scripts.add(script)\n    }\n  }\n}\n\nfunction applyToTargets(\n  { initErr }: InitContext,\n  mode: string,\n  element: DocumentFragment | Element,\n  capturedTargets: Iterable<Element>,\n) {\n  for (const target of capturedTargets) {\n    const cloned = element.cloneNode(true) as Element\n    if (mode === ElementPatchModeRemove) {\n      target.remove()\n    } else if (\n      mode === ElementPatchModeOuter ||\n      mode === ElementPatchModeInner\n    ) {\n      morph(target, cloned, mode)\n      execute(target)\n    } else {\n      execute(cloned)\n      if (mode === ElementPatchModeReplace) {\n        target.replaceWith(cloned)\n      } else if (mode === ElementPatchModePrepend) {\n        target.prepend(cloned)\n      } else if (mode === ElementPatchModeAppend) {\n        target.append(cloned)\n      } else if (mode === ElementPatchModeBefore) {\n        target.before(cloned)\n      } else if (mode === ElementPatchModeAfter) {\n        target.after(cloned)\n      } else {\n        throw initErr('InvalidPatchMode', { mode })\n      }\n    }\n  }\n}\n\nconst oldIdTagNameMap = new Map<string, string>()\nconst ctxIdMap = new Map<Node, Set<string>>()\nconst ctxPersistentIds = new Set<string>()\nconst duplicateIds = new Set<string>()\nconst ctxPantry = document.createElement('div')\nctxPantry.hidden = true\n\nfunction morph(\n  oldElt: Element,\n  newContent: DocumentFragment | Element,\n  mode: typeof ElementPatchModeInner | typeof ElementPatchModeOuter,\n): void {\n  const ignore = aliasify('ignore-morph')\n  if (\n    (oldElt.hasAttribute(ignore) &&\n      newContent instanceof HTMLElement &&\n      newContent.hasAttribute(ignore)) ||\n    oldElt.parentElement?.closest(`[${ignore}]`)\n  ) {\n    return\n  }\n\n  const normalizedElt = document.createElement('div')\n  normalizedElt.append(newContent)\n  document.body.insertAdjacentElement('afterend', ctxPantry)\n\n  // Computes the set of IDs that persist between the two contents excluding duplicates\n  const oldIdElements = oldElt.querySelectorAll('[id]')\n  for (const { id, tagName } of oldIdElements) {\n    if (oldIdTagNameMap.has(id)) {\n      duplicateIds.add(id)\n    } else {\n      oldIdTagNameMap.set(id, tagName)\n    }\n  }\n  if (oldElt.id) {\n    if (oldIdTagNameMap.has(oldElt.id)) {\n      duplicateIds.add(oldElt.id)\n    } else {\n      oldIdTagNameMap.set(oldElt.id, oldElt.tagName)\n    }\n  }\n\n  ctxPersistentIds.clear()\n  const newIdElements = normalizedElt.querySelectorAll('[id]')\n  for (const { id, tagName } of newIdElements) {\n    if (ctxPersistentIds.has(id)) {\n      duplicateIds.add(id)\n    } else if (oldIdTagNameMap.get(id) === tagName) {\n      ctxPersistentIds.add(id)\n    }\n  }\n\n  oldIdTagNameMap.clear()\n\n  for (const id of duplicateIds) {\n    ctxPersistentIds.delete(id)\n  }\n\n  duplicateIds.clear()\n\n  // Computes a map of nodes to all IDs contained within that node (inclusive of the node).\n  // This map can be used to ask if two nodes have intersecting sets of IDs,\n  // which allows for a looser definition of \"matching\" than traditional ID matching,\n  // and allows child nodes to contribute to a parent nodes matching.\n  // const idMap = new Map<Node, Set<string>>()\n  ctxIdMap.clear()\n\n  populateIdMapWithTree(\n    mode === 'outer' ? oldElt.parentElement! : oldElt,\n    oldIdElements,\n  )\n  populateIdMapWithTree(normalizedElt, newIdElements)\n\n  morphChildren(\n    mode === 'outer' ? oldElt.parentElement! : oldElt,\n    normalizedElt,\n    mode === 'outer' ? (oldElt as Node) : null,\n    oldElt.nextSibling,\n  )\n\n  ctxPantry.remove()\n}\n\n// This is the core algorithm for matching up children.\n// The idea is to use ID sets to try to match up nodes as faithfully as possible.\n// We greedily match, which allows us to keep the algorithm fast,\n// but by using ID sets, we are able to better match up with content deeper in the DOM.\nfunction morphChildren(\n  oldParent: Element, // the old content that we are merging the new content into\n  newParent: Element, // the parent element of the new content\n  insertionPoint: Node | null = null, // // the point in the DOM we start morphing at (defaults to first child)\n  endPoint: Node | null = null, // the point in the DOM we stop morphing at (defaults to after last child)\n): void {\n  // normalize\n  if (\n    oldParent instanceof HTMLTemplateElement &&\n    newParent instanceof HTMLTemplateElement\n  ) {\n    // we can pretend the DocumentElement is an Element\n    oldParent = oldParent.content as unknown as Element\n    newParent = newParent.content as unknown as Element\n  }\n  insertionPoint ??= oldParent.firstChild\n\n  // run through all the new content\n  for (const newChild of newParent.childNodes) {\n    // once we reach the end of the old parent content skip to the end and insert the rest\n    if (insertionPoint && insertionPoint !== endPoint) {\n      const bestMatch = findBestMatch(newChild, insertionPoint, endPoint)\n      if (bestMatch) {\n        // if the node to morph is not at the insertion point then remove/move up to it\n        if (bestMatch !== insertionPoint) {\n          let cursor: Node | null = insertionPoint\n          // Remove nodes between the start and end nodes\n          while (cursor && cursor !== bestMatch) {\n            const tempNode = cursor\n            cursor = cursor.nextSibling\n            removeNode(tempNode)\n          }\n        }\n        morphNode(bestMatch, newChild)\n        insertionPoint = bestMatch.nextSibling\n        continue\n      }\n    }\n\n    // @ts-ignore\n    const ncId = newChild.id\n    // if the matching node is elsewhere in the original content\n    if (newChild instanceof Element && ctxPersistentIds.has(ncId)) {\n      // move it and all its children here and morph, will always be found\n      // Search for an element by ID within the document and pantry, and move it using moveBefore.\n\n      const movedChild = window[ncId] as unknown as Element\n\n      // Removes an element from its ancestors' ID maps.\n      // This is needed when an element is moved from the \"future\" via `moveBeforeId`.\n      // Otherwise, its erstwhile ancestors could be mistakenly moved to the pantry rather than being deleted,\n      // preventing their removal hooks from being called.\n      let current = movedChild\n      while ((current = current.parentNode as Element)) {\n        const idSet = ctxIdMap.get(current)\n        if (idSet) {\n          idSet.delete(ncId)\n          if (!idSet.size) {\n            ctxIdMap.delete(current)\n          }\n        }\n      }\n\n      moveBefore(oldParent, movedChild, insertionPoint)\n      morphNode(movedChild, newChild)\n      insertionPoint = movedChild.nextSibling\n      continue\n    }\n\n    // This performs the action of inserting a new node while handling situations where the node contains\n    // elements with persistent IDs and possible state info we can still preserve by moving in and then morphing\n    if (ctxIdMap.has(newChild)) {\n      // node has children with IDs with possible state so create a dummy elt of same type and apply full morph algorithm\n      const newEmptyChild = document.createElement(\n        (newChild as Element).tagName,\n      )\n      oldParent.insertBefore(newEmptyChild, insertionPoint)\n      morphNode(newEmptyChild, newChild)\n      insertionPoint = newEmptyChild.nextSibling\n    } else {\n      // optimization: no id state to preserve so we can just insert a clone of the newChild and its descendants\n      const newClonedChild = document.importNode(newChild, true) // importNode to not mutate newParent\n      oldParent.insertBefore(newClonedChild, insertionPoint)\n      insertionPoint = newClonedChild.nextSibling\n    }\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint && insertionPoint !== endPoint) {\n    const tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling\n    removeNode(tempNode)\n  }\n}\n\n// Scans forward from the startPoint to the endPoint looking for a match for the node.\n// It looks for an id set match first, then a soft match.\n// We abort soft matching if we find two future soft matches, to reduce churn.\nfunction findBestMatch(\n  node: Node,\n  startPoint: Node | null,\n  endPoint: Node | null,\n): Node | null {\n  let bestMatch = null\n  let nextSibling = node.nextSibling\n  let siblingSoftMatchCount = 0\n  let displaceMatchCount = 0\n\n  // Max ID matches we are willing to displace in our search\n  const nodeMatchCount = ctxIdMap.get(node)?.size || 0\n\n  let cursor = startPoint\n  while (cursor && cursor !== endPoint) {\n    // soft matching is a prerequisite for id set matching\n    if (isSoftMatch(cursor, node)) {\n      let isIdSetMatch = false\n      const oldSet = ctxIdMap.get(cursor)\n      const newSet = ctxIdMap.get(node)\n\n      if (newSet && oldSet) {\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            isIdSetMatch = true\n            break\n          }\n        }\n      }\n\n      if (isIdSetMatch) {\n        return cursor // found an id set match, we're done!\n      }\n\n      // we haven\u2019t yet saved a soft match fallback\n      // the current soft match will hard match something else in the future, leave it\n      if (!bestMatch && !ctxIdMap.has(cursor)) {\n        // optimization: if node can't id set match, we can just return the soft match immediately\n        if (!nodeMatchCount) {\n          return cursor\n        }\n        // save this as the fallback if we get through the loop without finding a hard match\n        bestMatch = cursor\n      }\n    }\n    // check for IDs we may be displaced when matching\n    displaceMatchCount += ctxIdMap.get(cursor)?.size || 0\n    if (displaceMatchCount > nodeMatchCount) {\n      // if we are going to displace more IDs than the node contains then\n      // we do not have a good candidate for an ID match, so return\n      break\n    }\n\n    if (bestMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {\n      // The next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling\n\n      // If there are two future soft matches, block soft matching for this node to allow\n      // future siblings to soft match. This is to reduce churn in the DOM when an element\n      // is prepended.\n      if (siblingSoftMatchCount >= 2) {\n        bestMatch = undefined\n      }\n    }\n\n    // if the current node contains active element, stop looking for better future matches,\n    // because if one is found, this node will be moved to the pantry, re-parenting it and thus losing focus\n    if (cursor.contains(document.activeElement)) break\n\n    cursor = cursor.nextSibling\n  }\n\n  return bestMatch || null\n}\n\nfunction isSoftMatch(oldNode: Node, newNode: Node): boolean {\n  // ok to cast: if one is not element, `id` and `tagName` will be null and we'll just compare that.\n  const oldId = (oldNode as Element).id\n  return (\n    oldNode.nodeType === newNode.nodeType &&\n    (oldNode as Element).tagName === (newNode as Element).tagName &&\n    // If oldElt has an `id` with possible state and it doesn\u2019t match newElt.id then avoid morphing.\n    // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n    // its not persistent, and new nodes can't have any hidden state.\n    (!oldId || oldId === (newNode as Element).id)\n  )\n}\n\n// Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n// - Persistent nodes will be moved to the pantry for later reuse\n// - Other nodes will have their hooks called, and then are removed\nfunction removeNode(node: Node) {\n  // are we going to id set match this later?\n  if (ctxIdMap.has(node)) {\n    // skip callbacks and move to pantry\n    moveBefore(ctxPantry, node, null)\n  } else {\n    // remove for realsies\n    node.parentNode?.removeChild(node)\n  }\n}\n\n// Moves an element before another element within the same parent.\n// Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n// This is essentially a forward-compat wrapper.\nconst moveBefore: (parentNode: Node, node: Node, after: Node | null) => void =\n  // @ts-ignore\n  removeNode.call.bind(ctxPantry.moveBefore ?? ctxPantry.insertBefore)\n\nfunction morphNode(\n  oldNode: Node, // root node to merge content into\n  newNode: Node, // new content to merge\n): Node {\n  // syncs the oldNode to the newNode, copying over all attributes and\n  // inner element state from the newNode to the oldNode\n  const type = newNode.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const ignore = aliasify('ignore-morph')\n    if (\n      (oldNode as Element).hasAttribute(ignore) &&\n      (newNode as Element).hasAttribute(ignore)\n    ) {\n      return oldNode\n    }\n\n    //  many bothans died to bring us this information:\n    //  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    //  https://github.com/choojs/nanomorph/blob/master/lib/morph.js#L113\n    if (\n      oldNode instanceof HTMLInputElement &&\n      newNode instanceof HTMLInputElement &&\n      newNode.type !== 'file'\n    ) {\n      // https://github.com/bigskysoftware/idiomorph/issues/27\n      // | old input value | new input value  | behaviour                              |\n      // | --------------- | ---------------- | -------------------------------------- |\n      // | `null`          | `null`           | preserve old input value               |\n      // | some value      | the same value   | preserve old input value               |\n      // | some value      | `null`           | set old input value to `\"\"`            |\n      // | `null`          | some value       | set old input value to new input value |\n      // | some value      | some other value | set old input value to new input value |\n      if (newNode.getAttribute('value') !== oldNode.getAttribute('value')) {\n        oldNode.value = newNode.getAttribute('value') ?? ''\n      }\n    } else if (\n      oldNode instanceof HTMLTextAreaElement &&\n      newNode instanceof HTMLTextAreaElement\n    ) {\n      const newValue = newNode.value\n      if (newValue !== oldNode.value) {\n        oldNode.value = newValue\n      }\n      if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {\n        oldNode.firstChild.nodeValue = newValue\n      }\n    }\n\n    const preserveAttrs = (\n      (newNode as HTMLElement).getAttribute(aliasify('preserve-attr')) ?? ''\n    ).split(' ')\n\n    for (const { name, value } of (newNode as Element).attributes) {\n      if (\n        (oldNode as Element).getAttribute(name) !== value &&\n        !preserveAttrs.includes(kebab(name))\n      ) {\n        ;(oldNode as Element).setAttribute(name, value)\n      }\n    }\n\n    const oldAttrs = (oldNode as Element).attributes\n    for (let i = oldAttrs.length - 1; i >= 0; i--) {\n      const { name } = oldAttrs[i]\n      if (\n        !(newNode as Element).hasAttribute(name) &&\n        !preserveAttrs.includes(kebab(name))\n      ) {\n        ;(oldNode as Element).removeAttribute(name)\n      }\n    }\n  }\n\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (oldNode.nodeValue !== newNode.nodeValue) {\n      oldNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  if (!oldNode.isEqualNode(newNode)) {\n    morphChildren(oldNode as Element, newNode as Element)\n  }\n  return oldNode\n}\n\n// A bottom-up algorithm that populates a map of Element -> IdSet.\n// The ID set for a given element is the set of all IDs contained within its subtree.\n// As an optimization, we filter these IDs through the given list of persistent IDs,\n// because we don't need to bother considering IDed elements that won't be in the new content.\nfunction populateIdMapWithTree(\n  root: Element | null,\n  elements: Element[] | NodeListOf<Element>,\n) {\n  for (const elt of elements) {\n    if (ctxPersistentIds.has(elt.id)) {\n      let current: Element | null = elt\n      // walk up the parent hierarchy of that element, adding the ID of element to the parent's ID set\n      while (current && current !== root) {\n        let idSet = ctxIdMap.get(current)\n        // if the ID set doesn\u2019t exist, create it and insert it in the map\n        if (!idSet) {\n          idSet = new Set()\n          ctxIdMap.set(current, idSet)\n        }\n        idSet.add(elt.id)\n        current = current.parentElement\n      }\n    }\n  }\n}\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Patches signals.\n// Description: Patches signals.\n\nimport {\n  DefaultPatchSignalsOnlyIfMissing,\n  EventTypePatchSignals,\n} from '../../../engine/consts'\nimport type { WatcherPlugin } from '../../../engine/types'\nimport { isBoolString, jsStrToObject } from '../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const PatchSignals: WatcherPlugin = {\n  type: 'watcher',\n  name: EventTypePatchSignals,\n  onGlobalInit: (ctx) =>\n    datastarSSEEventWatcher(\n      EventTypePatchSignals,\n      ({\n        signals: raw = '{}',\n        onlyIfMissing: onlyIfMissingRaw = `${DefaultPatchSignalsOnlyIfMissing}`,\n      }) =>\n        ctx.mergePatch(jsStrToObject(raw), {\n          ifMissing: isBoolString(onlyIfMissingRaw),\n        }),\n    ),\n}\n", "import { apply, load, setAlias } from '../engine'\nimport { Peek } from '../plugins/actions/peek'\nimport { SetAll } from '../plugins/actions/setAll'\nimport { ToggleAll } from '../plugins/actions/toggleAll'\nimport { Attr } from '../plugins/attributes/attr'\nimport { Bind } from '../plugins/attributes/bind'\nimport { Class } from '../plugins/attributes/class'\nimport { Computed } from '../plugins/attributes/computed'\nimport { Effect } from '../plugins/attributes/effect'\nimport { Indicator } from '../plugins/attributes/indicator'\nimport { JsonSignals } from '../plugins/attributes/jsonSignals'\nimport { On } from '../plugins/attributes/on'\nimport { OnIntersect } from '../plugins/attributes/onIntersect'\nimport { OnInterval } from '../plugins/attributes/onInterval'\nimport { OnLoad } from '../plugins/attributes/onLoad'\nimport { OnSignalPatch } from \"../plugins/attributes/onSignalPatch\";\nimport { Ref } from '../plugins/attributes/ref'\nimport { Show } from '../plugins/attributes/show'\nimport { Signals } from '../plugins/attributes/signals'\nimport { Style } from '../plugins/attributes/style'\nimport { Text } from '../plugins/attributes/text'\nimport { DELETE } from '../plugins/backend/actions/delete'\nimport { GET } from '../plugins/backend/actions/get'\nimport { PATCH } from '../plugins/backend/actions/patch'\nimport { POST } from '../plugins/backend/actions/post'\nimport { PUT } from '../plugins/backend/actions/put'\nimport { PatchElements } from '../plugins/backend/watchers/patchElements'\nimport { PatchSignals } from '../plugins/backend/watchers/patchSignals'\n\nload(\n  // Backend\n  GET,\n  POST,\n  PUT,\n  PATCH,\n  DELETE,\n  PatchElements,\n  PatchSignals,\n  // Attributes\n  Attr,\n  Bind,\n  Class,\n  Computed,\n  Effect,\n  Indicator,\n  JsonSignals,\n  On,\n  OnIntersect,\n  OnInterval,\n  OnLoad,\n\tOnSignalPatch,\n  Ref,\n  Show,\n  Signals,\n  Style,\n  Text,\n  // Actions\n  Peek,\n  SetAll,\n  ToggleAll,\n)\n\napply()\n\nexport { apply, load, setAlias }\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "DATASTAR_REQUEST", "DefaultSseRetryDurationMs", "DefaultPatchSignalsOnlyIfMissing", "ElementPatchModeOuter", "ElementPatchModeInner", "ElementPatchModeRemove", "ElementPatchModeReplace", "ElementPatchModePrepend", "ElementPatchModeAppend", "ElementPatchModeBefore", "ElementPatchModeAfter", "DefaultElementPatchMode", "EventTypePatchElements", "EventTypePatchSignals", "isHTMLOrSVG", "el", "isPojo", "obj", "isEmpty", "prop", "updateLeaves", "fn", "key", "val", "pathToObj", "paths", "result", "path", "value", "keys", "lastKey", "acc", "isBoolString", "str", "kebab", "camel", "x", "snake", "pascal", "jsStrToObject", "raw", "caseFns", "modifyCasing", "mods", "c", "fn", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "snake", "q", "c", "initErr", "ctx", "reason", "metadata", "errCtx", "dserr", "runtimeErr", "DATASTAR_SIGNAL_PATCH_EVENT", "DATASTAR", "currentPatch", "queuedEffects", "batchDepth", "notifyIndex", "queuedEffectsLength", "activeSub", "startBatch", "endBatch", "flush", "dispatch", "signal", "initialValue", "signalOper", "value_", "flags_", "computedSymbol", "computed", "getter", "c", "computedOper", "effect", "fn", "e", "fn_", "link", "prev", "setCurrentSub", "effectOper", "peek", "run", "update", "updateComputed", "updateSignal", "sub", "prevSub", "startTracking", "oldValue", "endTracking", "s", "value", "notify", "flags", "subs", "subs_", "sub_", "checkDirty", "deps_", "dep", "dep_", "depFlags", "nextDep_", "shallowPropagate", "newValue", "propagate", "currentValue", "unlink", "prevDep", "depsTail_", "nextDep", "recursedCheck", "subsTail_", "isValidLink", "newLink", "prevDep_", "prevSub_", "nextSub_", "toRemove", "next", "stack", "top", "subSubs", "prev_", "checkDepth", "dirty", "firstSub", "hasMultipleSubs", "nextSub", "subFlags", "checkLink", "depsTail", "getPath", "path", "result", "root", "split", "DELETE", "deep", "prefix", "isArr", "isPojo", "deepObj", "key", "keys", "_", "prop", "diff", "patch", "i", "detail", "pathToObj", "DATASTAR_SIGNAL_PATCH_EVENT", "mergePatch", "ifMissing", "mergeInner", "mergePaths", "paths", "options", "target", "targetParent", "filtered", "include", "exclude", "obj", "node", "toRegExp", "val", "actions", "plugins", "pluginRegexs", "removals", "mutationObserver", "alias", "setAlias", "aliasify", "name", "load", "pluginsToLoad", "plugin", "ctx", "initErr", "a", "b", "lenDiff", "applyEls", "els", "ignore", "el", "applyAttributePlugin", "cleanupEls", "cleanups", "cleanup", "apply", "observe", "attrKey", "rawKey", "camel", "rawModifiers", "hasKey", "hasValue", "runtimeErr", "generateReactiveExpression", "keyReq", "valReq", "rawMod", "label", "mod", "t", "mutations", "type", "attributeName", "addedNodes", "removedNodes", "isHTMLOrSVG", "expr", "attrPlugin", "statementRe", "statements", "lastIdx", "last", "signalName", "acc", "part", "varName", "escaped", "escapeRe", "DSP", "DSS", "counter", "match", "k", "nameGen", "snake", "actionsCalled", "actionsRe", "actionMatches", "actionNames", "actionFns", "actionPrefix", "DATASTAR", "actionName", "action", "args", "v", "error", "Peek", "peek", "fn", "SetAll", "filtered", "mergePatch", "peek", "value", "filter", "masked", "updateLeaves", "ToggleAll", "filtered", "mergePatch", "peek", "filter", "masked", "updateLeaves", "oldValue", "Attr", "el", "effect", "key", "rx", "syncAttr", "val", "kebab", "update", "observer", "obj", "attributeFilter", "cleanup", "dataURIRegex", "empty", "Bind", "el", "key", "mods", "value", "effect", "mergePaths", "runtimeErr", "getPath", "signalName", "modifyCasing", "get", "type", "set", "syncSignal", "files", "contents", "mimes", "names", "f", "resolve", "reader", "match", "typeMap", "option", "initialValue", "path", "inputs", "aliasify", "paths", "i", "input", "signalValue", "cleanup", "Class", "key", "el", "effect", "mods", "rx", "modifyCasing", "kebab", "callback", "observer", "classes", "k", "classNames", "cn", "name", "cleanup", "Computed", "key", "mods", "rx", "computed", "mergePaths", "modifyCasing", "Effect", "effect", "rx", "DATASTAR_FETCH_EVENT", "DATASTAR", "STARTED", "FINISHED", "ERROR", "RETRYING", "RETRIES_FAILED", "datastarSSEEventWatcher", "eventType", "fn", "event", "argsRaw", "Indicator", "el", "key", "mods", "mergePaths", "value", "signalName", "modifyCasing", "watcher", "event", "type", "elt", "STARTED", "FINISHED", "DATASTAR_FETCH_EVENT", "JsonSignals", "el", "effect", "value", "filtered", "mods", "spaces", "filters", "jsStrToObject", "callback", "observer", "cleanup", "tagToMs", "args", "arg", "tagHas", "tags", "tag", "defaultValue", "delay", "callback", "wait", "args", "debounce", "leading", "trailing", "timer", "throttle", "waiting", "modifyTiming", "mods", "delayArgs", "tagToMs", "debounceArgs", "tagHas", "throttleArgs", "supportsViewTransitions", "modifyViewTransition", "callback", "mods", "cb", "args", "On", "ctx", "el", "key", "mods", "rx", "startBatch", "endBatch", "target", "callback", "evt", "modifyTiming", "modifyViewTransition", "evtListOpts", "cb", "eventName", "kebab", "modifyCasing", "DATASTAR_FETCH_EVENT", "DATASTAR_SIGNAL_PATCH_EVENT", "once", "OnIntersect", "el", "mods", "rx", "startBatch", "endBatch", "callback", "modifyTiming", "modifyViewTransition", "options", "observer", "entries", "entry", "OnInterval", "mods", "rx", "startBatch", "endBatch", "callback", "modifyViewTransition", "duration", "durationArgs", "tagToMs", "tagHas", "intervalId", "OnLoad", "rx", "mods", "startBatch", "endBatch", "callback", "modifyViewTransition", "wait", "delayArgs", "tagToMs", "delay", "OnSignalPatch", "el", "key", "mods", "plugin", "rx", "filtered", "runtimeErr", "startBatch", "endBatch", "filtersRaw", "filters", "jsStrToObject", "callback", "modifyTiming", "evt", "watched", "isEmpty", "DATASTAR_SIGNAL_PATCH_EVENT", "Ref", "el", "key", "mods", "value", "mergePaths", "signalName", "modifyCasing", "NONE", "DISPLAY", "Show", "el", "effect", "rx", "update", "observer", "cleanup", "Signals", "key", "mods", "rx", "mergePatch", "mergePaths", "ifMissing", "modifyCasing", "patch", "Style", "key", "el", "effect", "rx", "style", "initialStyles", "kebab", "apply", "prop", "value", "initial", "update", "observer", "styles", "cleanup", "Text", "el", "effect", "rx", "update", "observer", "cleanup", "fetchAbortControllers", "createHttpMethod", "name", "method", "ctx", "url", "args", "el", "requestCancellation", "controller", "isDisabled", "fetcher", "dispatchFetch", "type", "argsRaw", "DATASTAR_FETCH_EVENT", "isWrongContent", "err", "evt", "filtered", "runtimeErr", "selector", "userHeaders", "contentType", "include", "exclude", "openWhenHidden", "retryInterval", "DefaultSseRetryDurationMs", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "abort", "action", "cleanupFn", "initialHeaders", "DATASTAR_REQUEST", "headers", "req", "response", "ERROR", "DATASTAR", "argsRawLines", "line", "i", "k", "v", "error", "RETRYING", "urlInstance", "queryParams", "res", "formEl", "formData", "submitter", "preventDefault", "multipart", "formParams", "key", "value", "STARTED", "fetchEventSource", "FINISHED", "getBytes", "stream", "onChunk", "reader", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "field", "valueOffset", "retry", "a", "b", "input", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "inputFetch", "overrides", "rest", "resolve", "reject", "curRequestController", "onVisibilityChange", "create", "retryTimer", "dispose", "fetch", "onopen", "retries", "baseRetryInterval", "dispatchNonSSE", "dispatchType", "argNames", "n", "kebab", "o", "ct", "EventTypePatchElements", "EventTypePatchSignals", "script", "scriptAttributesHeader", "id", "interval", "RETRIES_FAILED", "innerErr", "DELETE", "createHttpMethod", "GET", "createHttpMethod", "PATCH", "createHttpMethod", "POST", "createHttpMethod", "PUT", "createHttpMethod", "PatchElements", "EventTypePatchElements", "ctx", "datastarSSEEventWatcher", "args", "supportsViewTransitions", "onPatchElements", "elements", "selector", "mode", "DefaultElementPatchMode", "initErr", "elementsWithSvgsRemoved", "hasHtml", "hasHead", "hasBody", "newDocument", "newContent", "ElementPatchModeOuter", "ElementPatchModeReplace", "child", "target", "applyToTargets", "targets", "scripts", "script", "execute", "elScripts", "old", "name", "value", "element", "capturedTargets", "cloned", "ElementPatchModeRemove", "ElementPatchModeInner", "morph", "ElementPatchModePrepend", "ElementPatchModeAppend", "ElementPatchModeBefore", "ElementPatchModeAfter", "oldIdTagNameMap", "ctxIdMap", "ctxPersistentIds", "duplicateIds", "ctxPantry", "oldElt", "ignore", "aliasify", "normalizedElt", "oldIdElements", "id", "tagName", "newIdElements", "populateIdMapWithTree", "morphChildren", "oldParent", "newParent", "insertionPoint", "endPoint", "newChild", "bestMatch", "findBestMatch", "cursor", "tempNode", "removeNode", "morphNode", "ncId", "movedChild", "current", "idSet", "moveBefore", "newEmptyChild", "newClonedChild", "node", "startPoint", "nextSibling", "siblingSoftMatchCount", "displaceMatchCount", "nodeMatchCount", "isSoftMatch", "isIdSetMatch", "oldSet", "newSet", "oldNode", "newNode", "oldId", "type", "newValue", "preserveAttrs", "kebab", "oldAttrs", "i", "root", "elt", "PatchSignals", "EventTypePatchSignals", "ctx", "datastarSSEEventWatcher", "raw", "onlyIfMissingRaw", "DefaultPatchSignalsOnlyIfMissing", "jsStrToObject", "isBoolString", "load", "GET", "POST", "PUT", "PATCH", "DELETE", "PatchElements", "PatchSignals", "Attr", "Bind", "Class", "Computed", "Effect", "Indicator", "JsonSignals", "On", "OnIntersect", "OnInterval", "OnLoad", "OnSignalPatch", "Ref", "Show", "Signals", "Style", "Text", "Peek", "SetAll", "ToggleAll", "apply"]
}
